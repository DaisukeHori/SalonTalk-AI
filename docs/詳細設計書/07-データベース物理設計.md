## 7. データベース物理設計

### 7.1 物理スキーマ定義

#### 7.1.1 完全なDDL（Data Definition Language）

```sql
-- ============================================================
-- SalonTalk AI データベース物理設計
-- PostgreSQL 15+ / Supabase
-- ============================================================

-- ============================================================
-- 拡張機能の有効化
-- ============================================================

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "vector";

-- ============================================================
-- カスタム型定義
-- ============================================================
-- ⚠️ 実装に合わせて修正（2025-12-05）

-- プラン種別（実装に合わせて修正: free追加、professional→premium）
CREATE TYPE plan_type AS ENUM ('free', 'standard', 'premium', 'enterprise');

-- スタッフロール（実装に合わせて修正: assistant→admin）
CREATE TYPE staff_role AS ENUM ('owner', 'manager', 'stylist', 'admin');

-- セッションステータス（実装に合わせて修正: analyzing追加、failed→error）
CREATE TYPE session_status AS ENUM ('recording', 'processing', 'analyzing', 'completed', 'error');

-- 話者分離ステータス
CREATE TYPE diarization_status AS ENUM ('pending', 'processing', 'completed', 'failed');

-- 話者
CREATE TYPE speaker_type AS ENUM ('stylist', 'customer', 'unknown');

-- 分析指標タイプ
CREATE TYPE indicator_type AS ENUM (
  'talk_ratio',
  'question_analysis',
  'emotion_analysis',
  'concern_keywords',
  'proposal_timing',
  'proposal_quality',
  'conversion'
);

-- ============================================================
-- テーブル定義
-- ============================================================

-- ------------------------------------------------------------
-- salons（店舗）
-- ------------------------------------------------------------
CREATE TABLE salons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  address TEXT,
  phone VARCHAR(20),
  plan plan_type NOT NULL DEFAULT 'standard',
  seats_count INTEGER CHECK (seats_count IS NULL OR seats_count > 0),
  settings JSONB NOT NULL DEFAULT '{
    "notification": {
      "enablePush": true,
      "enableEmail": true,
      "concernDetectionAlert": true,
      "sessionCompleteAlert": true
    },
    "analysis": {
      "idealTalkRatio": 40,
      "minQuestionCount": 8,
      "concernKeywords": ["乾燥", "広がり", "パサつき", "ダメージ", "うねり", "薄毛", "白髪"]
    },
    "display": {
      "showRanking": true,
      "anonymizeCustomer": false
    }
  }'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- インデックス
CREATE INDEX idx_salons_plan ON salons(plan);
CREATE INDEX idx_salons_created_at ON salons(created_at);

-- 更新日時自動更新トリガー
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_salons_updated_at
  BEFORE UPDATE ON salons
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- staffs（スタッフ）
-- ⚠️ 実装に合わせて修正（2025-12-05）: id=auth.users(id)構造
-- ------------------------------------------------------------
CREATE TABLE staffs (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  name VARCHAR(50) NOT NULL,
  email VARCHAR(255) NOT NULL,
  role staff_role NOT NULL DEFAULT 'stylist',
  avatar_url TEXT,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT staffs_email_unique UNIQUE (email)
);

-- インデックス
CREATE INDEX idx_staffs_salon_id ON staffs(salon_id);
CREATE INDEX idx_staffs_role ON staffs(role);
CREATE INDEX idx_staffs_is_active ON staffs(is_active);
CREATE INDEX idx_staffs_salon_active ON staffs(salon_id, is_active) WHERE is_active = true;

CREATE TRIGGER update_staffs_updated_at
  BEFORE UPDATE ON staffs
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- sessions（セッション）
-- ------------------------------------------------------------
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  stylist_id UUID NOT NULL REFERENCES staffs(id) ON DELETE CASCADE,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  status session_status NOT NULL DEFAULT 'recording',
  customer_info JSONB,
  diarization_status diarization_status NOT NULL DEFAULT 'pending',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT sessions_end_after_start CHECK (ended_at IS NULL OR ended_at >= started_at)
);

-- インデックス
CREATE INDEX idx_sessions_salon_id ON sessions(salon_id);
CREATE INDEX idx_sessions_stylist_id ON sessions(stylist_id);
CREATE INDEX idx_sessions_status ON sessions(status);
CREATE INDEX idx_sessions_started_at ON sessions(started_at DESC);
CREATE INDEX idx_sessions_salon_started ON sessions(salon_id, started_at DESC);
CREATE INDEX idx_sessions_stylist_started ON sessions(stylist_id, started_at DESC);
CREATE INDEX idx_sessions_active ON sessions(stylist_id, status) WHERE status = 'recording';

-- 月別パーティション用（将来拡張）
-- CREATE INDEX idx_sessions_started_month ON sessions(date_trunc('month', started_at));

CREATE TRIGGER update_sessions_updated_at
  BEFORE UPDATE ON sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- transcripts（文字起こし）
-- ------------------------------------------------------------
CREATE TABLE transcripts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  text TEXT NOT NULL,
  start_time NUMERIC(10, 3) NOT NULL,
  end_time NUMERIC(10, 3) NOT NULL,
  audio_url TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT transcripts_session_chunk_unique UNIQUE (session_id, chunk_index),
  CONSTRAINT transcripts_time_valid CHECK (end_time > start_time)
);

-- インデックス
CREATE INDEX idx_transcripts_session_id ON transcripts(session_id);
CREATE INDEX idx_transcripts_session_chunk ON transcripts(session_id, chunk_index);

-- ------------------------------------------------------------
-- speaker_segments（話者セグメント）
-- ------------------------------------------------------------
CREATE TABLE speaker_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  speaker speaker_type NOT NULL,
  start_time NUMERIC(10, 3) NOT NULL,
  end_time NUMERIC(10, 3) NOT NULL,
  text TEXT,
  confidence NUMERIC(5, 4) CHECK (confidence IS NULL OR (confidence >= 0 AND confidence <= 1)),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT speaker_segments_time_valid CHECK (end_time > start_time)
);

-- インデックス
CREATE INDEX idx_speaker_segments_session_id ON speaker_segments(session_id);
CREATE INDEX idx_speaker_segments_speaker ON speaker_segments(speaker);
CREATE INDEX idx_speaker_segments_session_time ON speaker_segments(session_id, start_time);

-- ------------------------------------------------------------
-- session_analyses（セッション分析）
-- ------------------------------------------------------------
CREATE TABLE session_analyses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  indicator_type indicator_type NOT NULL,
  value NUMERIC(10, 4) NOT NULL,
  score INTEGER NOT NULL CHECK (score >= 0 AND score <= 100),
  details JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT session_analyses_unique UNIQUE (session_id, chunk_index, indicator_type)
);

-- インデックス
CREATE INDEX idx_session_analyses_session_id ON session_analyses(session_id);
CREATE INDEX idx_session_analyses_indicator ON session_analyses(indicator_type);
CREATE INDEX idx_session_analyses_session_chunk ON session_analyses(session_id, chunk_index);
CREATE INDEX idx_session_analyses_session_indicator ON session_analyses(session_id, indicator_type);

-- ------------------------------------------------------------
-- session_reports（セッションレポート）
-- ------------------------------------------------------------
CREATE TABLE session_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  overall_score INTEGER NOT NULL CHECK (overall_score >= 0 AND overall_score <= 100),
  good_points TEXT[] NOT NULL DEFAULT '{}',
  improvement_points TEXT[] NOT NULL DEFAULT '{}',
  action_items TEXT[] NOT NULL DEFAULT '{}',
  transcript_summary TEXT,
  ai_feedback TEXT,
  indicator_scores JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT session_reports_session_unique UNIQUE (session_id)
);

-- インデックス
CREATE INDEX idx_session_reports_session_id ON session_reports(session_id);
CREATE INDEX idx_session_reports_score ON session_reports(overall_score DESC);
CREATE INDEX idx_session_reports_created_at ON session_reports(created_at DESC);

-- ------------------------------------------------------------
-- success_cases（成功事例）
-- ------------------------------------------------------------
CREATE TABLE success_cases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  session_id UUID REFERENCES sessions(id) ON DELETE SET NULL,
  stylist_id UUID REFERENCES staffs(id) ON DELETE SET NULL,
  concern_keywords TEXT[] NOT NULL DEFAULT '{}',
  customer_profile JSONB,
  successful_talk TEXT NOT NULL,
  key_tactics TEXT[] NOT NULL DEFAULT '{}',
  sold_product VARCHAR(100),
  conversion_rate NUMERIC(5, 4) CHECK (conversion_rate IS NULL OR (conversion_rate >= 0 AND conversion_rate <= 1)),
  embedding VECTOR(1536),
  is_public BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- インデックス
CREATE INDEX idx_success_cases_salon_id ON success_cases(salon_id);
CREATE INDEX idx_success_cases_is_public ON success_cases(is_public);
CREATE INDEX idx_success_cases_concern ON success_cases USING GIN(concern_keywords);
CREATE INDEX idx_success_cases_created_at ON success_cases(created_at DESC);

-- HNSWベクトルインデックス（高速近似最近傍探索）
CREATE INDEX idx_success_cases_embedding ON success_cases 
  USING hnsw (embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- ------------------------------------------------------------
-- training_scenarios（トレーニングシナリオ）
-- ------------------------------------------------------------
CREATE TABLE training_scenarios (
  id VARCHAR(50) PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  level VARCHAR(20) NOT NULL CHECK (level IN ('beginner', 'intermediate', 'advanced')),
  description TEXT,
  category VARCHAR(50) NOT NULL,
  initial_prompt TEXT NOT NULL,
  evaluation_criteria JSONB NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_training_scenarios_level ON training_scenarios(level);
CREATE INDEX idx_training_scenarios_category ON training_scenarios(category);
CREATE INDEX idx_training_scenarios_active ON training_scenarios(is_active);

-- ------------------------------------------------------------
-- roleplay_sessions（ロールプレイセッション）
-- ------------------------------------------------------------
CREATE TABLE roleplay_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  staff_id UUID NOT NULL REFERENCES staffs(id) ON DELETE CASCADE,
  scenario_id VARCHAR(50) NOT NULL REFERENCES training_scenarios(id),
  conversation_history JSONB NOT NULL DEFAULT '[]',
  evaluation JSONB,
  overall_score INTEGER CHECK (overall_score IS NULL OR (overall_score >= 0 AND overall_score <= 100)),
  status VARCHAR(20) NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned')),
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_roleplay_sessions_staff_id ON roleplay_sessions(staff_id);
CREATE INDEX idx_roleplay_sessions_scenario_id ON roleplay_sessions(scenario_id);
CREATE INDEX idx_roleplay_sessions_status ON roleplay_sessions(status);

-- ------------------------------------------------------------
-- audit_logs（監査ログ）
-- ------------------------------------------------------------
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type VARCHAR(50) NOT NULL,
  user_id UUID REFERENCES staffs(id),
  salon_id UUID REFERENCES salons(id),
  resource_type VARCHAR(50),
  resource_id UUID,
  action VARCHAR(20),
  old_value JSONB,
  new_value JSONB,
  ip_address INET,
  user_agent TEXT,
  request_id UUID,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- インデックス
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_salon ON audit_logs(salon_id, created_at DESC);
CREATE INDEX idx_audit_logs_event ON audit_logs(event_type, created_at DESC);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);

-- 自動削除（90日経過後）
CREATE OR REPLACE FUNCTION delete_old_audit_logs()
RETURNS void AS $$
BEGIN
  DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL '90 days';
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- RLS（Row Level Security）ポリシー
-- ============================================================

-- RLS有効化
ALTER TABLE salons ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffs ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE transcripts ENABLE ROW LEVEL SECURITY;
ALTER TABLE speaker_segments ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_analyses ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE success_cases ENABLE ROW LEVEL SECURITY;
ALTER TABLE roleplay_sessions ENABLE ROW LEVEL SECURITY;

-- ユーティリティ関数
CREATE OR REPLACE FUNCTION get_current_user_salon_id()
RETURNS UUID AS $$
  SELECT salon_id FROM staffs WHERE auth_user_id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION get_current_user_role()
RETURNS staff_role AS $$
  SELECT role FROM staffs WHERE auth_user_id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION get_current_user_staff_id()
RETURNS UUID AS $$
  SELECT id FROM staffs WHERE auth_user_id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

-- salons ポリシー
CREATE POLICY "salon_select" ON salons
  FOR SELECT USING (id = get_current_user_salon_id());

CREATE POLICY "salon_update" ON salons
  FOR UPDATE USING (
    id = get_current_user_salon_id() 
    AND get_current_user_role() = 'owner'
  );

-- staffs ポリシー
CREATE POLICY "staff_select" ON staffs
  FOR SELECT USING (salon_id = get_current_user_salon_id());

CREATE POLICY "staff_insert" ON staffs
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "staff_update" ON staffs
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "staff_delete" ON staffs
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() = 'owner'
  );

-- sessions ポリシー
CREATE POLICY "session_select_own" ON sessions
  FOR SELECT USING (
    salon_id = get_current_user_salon_id()
    AND (
      stylist_id = get_current_user_staff_id()
      OR get_current_user_role() IN ('owner', 'manager')
    )
  );

CREATE POLICY "session_insert" ON sessions
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND stylist_id = get_current_user_staff_id()
    AND get_current_user_role() IN ('owner', 'manager', 'stylist')
  );

CREATE POLICY "session_update" ON sessions
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND stylist_id = get_current_user_staff_id()
  );

-- transcripts ポリシー
CREATE POLICY "transcript_all" ON transcripts
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- speaker_segments ポリシー
CREATE POLICY "speaker_segment_all" ON speaker_segments
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- session_analyses ポリシー
CREATE POLICY "analysis_all" ON session_analyses
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- session_reports ポリシー
CREATE POLICY "report_all" ON session_reports
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- success_cases ポリシー
CREATE POLICY "success_case_select" ON success_cases
  FOR SELECT USING (
    is_public = true
    OR salon_id = get_current_user_salon_id()
  );

CREATE POLICY "success_case_insert" ON success_cases
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "success_case_update" ON success_cases
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "success_case_delete" ON success_cases
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() = 'owner'
  );

-- roleplay_sessions ポリシー
CREATE POLICY "roleplay_select" ON roleplay_sessions
  FOR SELECT USING (
    staff_id = get_current_user_staff_id()
    OR get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "roleplay_insert" ON roleplay_sessions
  FOR INSERT WITH CHECK (
    staff_id = get_current_user_staff_id()
  );

CREATE POLICY "roleplay_update" ON roleplay_sessions
  FOR UPDATE USING (
    staff_id = get_current_user_staff_id()
  );

-- ============================================================
-- 関数・プロシージャ
-- ============================================================

-- ベクトル類似検索関数
CREATE OR REPLACE FUNCTION search_success_cases(
  query_embedding VECTOR(1536),
  match_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 5,
  p_salon_id UUID DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  concern_keywords TEXT[],
  successful_talk TEXT,
  key_tactics TEXT[],
  sold_product VARCHAR,
  similarity FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    sc.id,
    sc.concern_keywords,
    sc.successful_talk,
    sc.key_tactics,
    sc.sold_product,
    1 - (sc.embedding <=> query_embedding) AS similarity
  FROM success_cases sc
  WHERE
    sc.embedding IS NOT NULL
    AND (sc.is_public = true OR sc.salon_id = p_salon_id)
    AND 1 - (sc.embedding <=> query_embedding) > match_threshold
  ORDER BY sc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- スタッフ統計取得関数
CREATE OR REPLACE FUNCTION get_staff_statistics(
  p_staff_id UUID,
  p_start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '30 days',
  p_end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
  total_sessions BIGINT,
  avg_score NUMERIC,
  conversion_count BIGINT,
  conversion_rate NUMERIC,
  total_duration_minutes BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(DISTINCT s.id) AS total_sessions,
    COALESCE(ROUND(AVG(sr.overall_score), 1), 0) AS avg_score,
    COALESCE(
      SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END),
      0
    ) AS conversion_count,
    COALESCE(
      ROUND(
        SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END)::NUMERIC / 
        NULLIF(COUNT(DISTINCT s.id), 0) * 100,
        1
      ),
      0
    ) AS conversion_rate,
    COALESCE(
      SUM(EXTRACT(EPOCH FROM (s.ended_at - s.started_at)) / 60)::BIGINT,
      0
    ) AS total_duration_minutes
  FROM sessions s
  LEFT JOIN session_reports sr ON sr.session_id = s.id
  LEFT JOIN session_analyses sa ON sa.session_id = s.id AND sa.indicator_type = 'conversion'
  WHERE
    s.stylist_id = p_staff_id
    AND s.status = 'completed'
    AND s.started_at >= p_start_date
    AND s.started_at <= p_end_date;
END;
$$;

-- 店舗統計取得関数
CREATE OR REPLACE FUNCTION get_salon_statistics(
  p_salon_id UUID,
  p_start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '30 days',
  p_end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
  total_sessions BIGINT,
  avg_score NUMERIC,
  conversion_rate NUMERIC,
  active_stylists BIGINT,
  top_performer_id UUID,
  top_performer_name VARCHAR,
  top_performer_score NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH session_stats AS (
    SELECT
      s.stylist_id,
      COUNT(*) AS session_count,
      AVG(sr.overall_score) AS avg_score
    FROM sessions s
    LEFT JOIN session_reports sr ON sr.session_id = s.id
    WHERE
      s.salon_id = p_salon_id
      AND s.status = 'completed'
      AND s.started_at >= p_start_date
      AND s.started_at <= p_end_date
    GROUP BY s.stylist_id
  ),
  top_performer AS (
    SELECT
      st.id,
      st.name,
      ss.avg_score
    FROM session_stats ss
    JOIN staffs st ON st.id = ss.stylist_id
    ORDER BY ss.avg_score DESC NULLS LAST
    LIMIT 1
  )
  SELECT
    (SELECT COUNT(*) FROM sessions WHERE salon_id = p_salon_id AND status = 'completed' AND started_at >= p_start_date AND started_at <= p_end_date) AS total_sessions,
    (SELECT ROUND(AVG(sr.overall_score), 1) FROM sessions s JOIN session_reports sr ON sr.session_id = s.id WHERE s.salon_id = p_salon_id AND s.status = 'completed' AND s.started_at >= p_start_date AND s.started_at <= p_end_date) AS avg_score,
    (SELECT ROUND(
      SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END)::NUMERIC / 
      NULLIF(COUNT(DISTINCT s.id), 0) * 100, 1)
    FROM sessions s
    LEFT JOIN session_analyses sa ON sa.session_id = s.id AND sa.indicator_type = 'conversion'
    WHERE s.salon_id = p_salon_id AND s.status = 'completed' AND s.started_at >= p_start_date AND s.started_at <= p_end_date
    ) AS conversion_rate,
    (SELECT COUNT(DISTINCT stylist_id) FROM sessions WHERE salon_id = p_salon_id AND started_at >= p_start_date AND started_at <= p_end_date) AS active_stylists,
    tp.id AS top_performer_id,
    tp.name AS top_performer_name,
    ROUND(tp.avg_score, 1) AS top_performer_score
  FROM top_performer tp;
END;
$$;
```

### 7.2 インデックス設計

#### 7.2.1 インデックス一覧

| テーブル | インデックス名 | カラム | 種別 | 用途 |
|---------|--------------|--------|------|------|
| salons | idx_salons_plan | plan | B-tree | プラン別検索 |
| staffs | idx_staffs_salon_id | salon_id | B-tree | 店舗別スタッフ取得 |
| staffs | idx_staffs_auth_user_id | auth_user_id | B-tree | 認証ユーザー検索 |
| staffs | idx_staffs_salon_active | salon_id, is_active | B-tree (部分) | アクティブスタッフ取得 |
| sessions | idx_sessions_salon_started | salon_id, started_at | B-tree | 店舗別セッション履歴 |
| sessions | idx_sessions_stylist_started | stylist_id, started_at | B-tree | スタイリスト別履歴 |
| sessions | idx_sessions_active | stylist_id, status | B-tree (部分) | アクティブセッション検索 |
| transcripts | idx_transcripts_session_chunk | session_id, chunk_index | B-tree | チャンク順取得 |
| speaker_segments | idx_speaker_segments_session_time | session_id, start_time | B-tree | 時系列取得 |
| session_analyses | idx_session_analyses_session_indicator | session_id, indicator_type | B-tree | 指標別分析取得 |
| session_reports | idx_session_reports_score | overall_score | B-tree (DESC) | スコアランキング |
| success_cases | idx_success_cases_concern | concern_keywords | GIN | キーワード検索 |
| success_cases | idx_success_cases_embedding | embedding | HNSW | ベクトル類似検索 |

#### 7.2.2 パフォーマンスチューニング設定

```sql
-- PostgreSQL設定推奨値（Supabase Pro以上）

-- shared_buffers: メモリの25%程度
-- effective_cache_size: メモリの75%程度
-- work_mem: 64MB（複雑なソート・集計用）
-- maintenance_work_mem: 512MB（インデックス作成用）

-- HNSWインデックスの検索精度設定
SET hnsw.ef_search = 100;  -- 検索時の探索範囲（大きいほど精度↑、速度↓）

-- 統計情報の更新
ANALYZE salons;
ANALYZE staffs;
ANALYZE sessions;
ANALYZE transcripts;
ANALYZE speaker_segments;
ANALYZE session_analyses;
ANALYZE session_reports;
ANALYZE success_cases;
```

---
