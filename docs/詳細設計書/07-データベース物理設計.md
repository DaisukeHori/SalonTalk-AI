## 7. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç‰©ç†è¨­è¨ˆ

### 7.1 ç‰©ç†ã‚¹ã‚­ãƒ¼ãƒå®šç¾©

#### 7.1.1 å®Œå…¨ãªDDLï¼ˆData Definition Languageï¼‰

```sql
-- ============================================================
-- SalonTalk AI ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç‰©ç†è¨­è¨ˆ
-- PostgreSQL 15+ / Supabase
-- ============================================================

-- ============================================================
-- æ‹¡å¼µæ©Ÿèƒ½ã®æœ‰åŠ¹åŒ–
-- ============================================================

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "vector";

-- ============================================================
-- ã‚«ã‚¹ã‚¿ãƒ å‹å®šç¾©
-- ============================================================
-- âš ï¸ å®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£ï¼ˆ2025-12-05ï¼‰

-- ãƒ—ãƒ©ãƒ³ç¨®åˆ¥ï¼ˆå®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£: freeè¿½åŠ ã€professionalâ†’premiumï¼‰
CREATE TYPE plan_type AS ENUM ('free', 'standard', 'premium', 'enterprise');

-- ã‚¹ã‚¿ãƒƒãƒ•ãƒ­ãƒ¼ãƒ«ï¼ˆå®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£: assistantâ†’adminï¼‰
CREATE TYPE staff_role AS ENUM ('owner', 'manager', 'stylist', 'admin');

-- ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆå®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£: analyzingè¿½åŠ ã€failedâ†’errorï¼‰
CREATE TYPE session_status AS ENUM ('recording', 'processing', 'analyzing', 'completed', 'error');

-- è©±è€…åˆ†é›¢ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
CREATE TYPE diarization_status AS ENUM ('pending', 'processing', 'completed', 'failed');

-- è©±è€…
CREATE TYPE speaker_type AS ENUM ('stylist', 'customer', 'unknown');

-- åˆ†ææŒ‡æ¨™ã‚¿ã‚¤ãƒ—
CREATE TYPE indicator_type AS ENUM (
  'talk_ratio',
  'question_analysis',
  'emotion_analysis',
  'concern_keywords',
  'proposal_timing',
  'proposal_quality',
  'conversion'
);

-- ============================================================
-- ãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©
-- ============================================================

-- ------------------------------------------------------------
-- salonsï¼ˆåº—èˆ—ï¼‰
-- ------------------------------------------------------------
CREATE TABLE salons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  address TEXT,
  phone VARCHAR(20),
  plan plan_type NOT NULL DEFAULT 'standard',
  seats_count INTEGER CHECK (seats_count IS NULL OR seats_count > 0),
  settings JSONB NOT NULL DEFAULT '{
    "notification": {
      "enablePush": true,
      "enableEmail": true,
      "concernDetectionAlert": true,
      "sessionCompleteAlert": true
    },
    "analysis": {
      "idealTalkRatio": 40,
      "minQuestionCount": 8,
      "concernKeywords": ["ä¹¾ç‡¥", "åºƒãŒã‚Š", "ãƒ‘ã‚µã¤ã", "ãƒ€ãƒ¡ãƒ¼ã‚¸", "ã†ã­ã‚Š", "è–„æ¯›", "ç™½é«ª"]
    },
    "display": {
      "showRanking": true,
      "anonymizeCustomer": false
    }
  }'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_salons_plan ON salons(plan);
CREATE INDEX idx_salons_created_at ON salons(created_at);

-- æ›´æ–°æ—¥æ™‚è‡ªå‹•æ›´æ–°ãƒˆãƒªã‚¬ãƒ¼
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_salons_updated_at
  BEFORE UPDATE ON salons
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- staffsï¼ˆã‚¹ã‚¿ãƒƒãƒ•ï¼‰
-- âš ï¸ å®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£ï¼ˆ2025-12-05ï¼‰: id=auth.users(id)æ§‹é€ 
-- ------------------------------------------------------------
CREATE TABLE staffs (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  name VARCHAR(50) NOT NULL,
  email VARCHAR(255) NOT NULL,
  role staff_role NOT NULL DEFAULT 'stylist',
  avatar_url TEXT,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT staffs_email_unique UNIQUE (email)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_staffs_salon_id ON staffs(salon_id);
CREATE INDEX idx_staffs_role ON staffs(role);
CREATE INDEX idx_staffs_is_active ON staffs(is_active);
CREATE INDEX idx_staffs_salon_active ON staffs(salon_id, is_active) WHERE is_active = true;

CREATE TRIGGER update_staffs_updated_at
  BEFORE UPDATE ON staffs
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- sessionsï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼‰
-- ------------------------------------------------------------
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  stylist_id UUID NOT NULL REFERENCES staffs(id) ON DELETE CASCADE,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  status session_status NOT NULL DEFAULT 'recording',
  customer_info JSONB,
  diarization_status diarization_status NOT NULL DEFAULT 'pending',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT sessions_end_after_start CHECK (ended_at IS NULL OR ended_at >= started_at)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_sessions_salon_id ON sessions(salon_id);
CREATE INDEX idx_sessions_stylist_id ON sessions(stylist_id);
CREATE INDEX idx_sessions_status ON sessions(status);
CREATE INDEX idx_sessions_started_at ON sessions(started_at DESC);
CREATE INDEX idx_sessions_salon_started ON sessions(salon_id, started_at DESC);
CREATE INDEX idx_sessions_stylist_started ON sessions(stylist_id, started_at DESC);
CREATE INDEX idx_sessions_active ON sessions(stylist_id, status) WHERE status = 'recording';

-- æœˆåˆ¥ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³ç”¨ï¼ˆå°†æ¥æ‹¡å¼µï¼‰
-- CREATE INDEX idx_sessions_started_month ON sessions(date_trunc('month', started_at));

CREATE TRIGGER update_sessions_updated_at
  BEFORE UPDATE ON sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- transcriptsï¼ˆæ–‡å­—èµ·ã“ã—ï¼‰
-- æ™‚é–“å˜ä½ã¯ãƒŸãƒªç§’ã§çµ±ä¸€ï¼ˆspeaker_segmentsã¨ä¸€è‡´ï¼‰
-- ------------------------------------------------------------
CREATE TABLE transcripts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  text TEXT NOT NULL,
  start_time_ms INTEGER NOT NULL,
  end_time_ms INTEGER NOT NULL,
  audio_url TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT transcripts_session_chunk_unique UNIQUE (session_id, chunk_index),
  CONSTRAINT transcripts_time_valid CHECK (end_time_ms > start_time_ms)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_transcripts_session_id ON transcripts(session_id);
CREATE INDEX idx_transcripts_session_chunk ON transcripts(session_id, chunk_index);

-- ------------------------------------------------------------
-- speaker_segmentsï¼ˆè©±è€…ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼‰
-- æ™‚é–“å˜ä½ã¯ãƒŸãƒªç§’ã§çµ±ä¸€ï¼ˆtranscriptsã¨ä¸€è‡´ï¼‰
-- ------------------------------------------------------------
CREATE TABLE speaker_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  speaker speaker_type NOT NULL,
  start_time_ms INTEGER NOT NULL,
  end_time_ms INTEGER NOT NULL,
  text TEXT,
  confidence NUMERIC(5, 4) CHECK (confidence IS NULL OR (confidence >= 0 AND confidence <= 1)),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT speaker_segments_time_valid CHECK (end_time_ms > start_time_ms)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_speaker_segments_session_id ON speaker_segments(session_id);
CREATE INDEX idx_speaker_segments_speaker ON speaker_segments(speaker);
CREATE INDEX idx_speaker_segments_session_time ON speaker_segments(session_id, start_time_ms);

-- ------------------------------------------------------------
-- session_analysesï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³åˆ†æï¼‰
-- ------------------------------------------------------------
CREATE TABLE session_analyses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  indicator_type indicator_type NOT NULL,
  value NUMERIC(10, 4) NOT NULL,
  score INTEGER NOT NULL CHECK (score >= 0 AND score <= 100),
  details JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT session_analyses_unique UNIQUE (session_id, chunk_index, indicator_type)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_session_analyses_session_id ON session_analyses(session_id);
CREATE INDEX idx_session_analyses_indicator ON session_analyses(indicator_type);
CREATE INDEX idx_session_analyses_session_chunk ON session_analyses(session_id, chunk_index);
CREATE INDEX idx_session_analyses_session_indicator ON session_analyses(session_id, indicator_type);

-- ------------------------------------------------------------
-- session_reportsï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆï¼‰
-- ã‚«ãƒ©ãƒ åã¯å®Ÿè£…ã¨ä¸€è‡´: summary, strengths, improvements, metrics
-- ------------------------------------------------------------
CREATE TABLE session_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE UNIQUE,
  summary TEXT NOT NULL,
  overall_score INTEGER NOT NULL CHECK (overall_score >= 0 AND overall_score <= 100),
  metrics JSONB NOT NULL DEFAULT '{}',
  stylist_ratio INTEGER,
  customer_ratio INTEGER,
  open_question_count INTEGER DEFAULT 0,
  closed_question_count INTEGER DEFAULT 0,
  positive_ratio INTEGER,
  concern_keywords TEXT[] DEFAULT '{}',
  proposal_timing_ms INTEGER,
  proposal_match_rate INTEGER,
  is_converted BOOLEAN DEFAULT FALSE,
  improvements TEXT[] DEFAULT '{}',
  strengths TEXT[] DEFAULT '{}',
  matched_cases JSONB DEFAULT '[]',
  generated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_session_reports_session_id ON session_reports(session_id);
CREATE INDEX idx_session_reports_score ON session_reports(overall_score DESC);
CREATE INDEX idx_session_reports_created_at ON session_reports(created_at DESC);

-- ------------------------------------------------------------
-- success_casesï¼ˆæˆåŠŸäº‹ä¾‹ï¼‰
-- ã‚«ãƒ©ãƒ åã¯å®Ÿè£…ã¨ä¸€è‡´: approach_text, result, is_activeè¿½åŠ 
-- ------------------------------------------------------------
CREATE TABLE success_cases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  session_id UUID REFERENCES sessions(id) ON DELETE SET NULL,
  stylist_id UUID REFERENCES staffs(id) ON DELETE SET NULL,
  concern_keywords TEXT[] NOT NULL,
  customer_profile JSONB,
  approach_text TEXT NOT NULL,
  successful_talk TEXT,
  key_tactics TEXT[],
  result TEXT NOT NULL,
  sold_product TEXT,
  conversion_rate REAL,
  embedding VECTOR(1536),
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  is_public BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_success_cases_salon_id ON success_cases(salon_id);
CREATE INDEX idx_success_cases_is_public ON success_cases(is_public);
CREATE INDEX idx_success_cases_concern ON success_cases USING GIN(concern_keywords);
CREATE INDEX idx_success_cases_created_at ON success_cases(created_at DESC);

-- HNSWãƒ™ã‚¯ãƒˆãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆé«˜é€Ÿè¿‘ä¼¼æœ€è¿‘å‚æ¢ç´¢ï¼‰
CREATE INDEX idx_success_cases_embedding ON success_cases
  USING hnsw (embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- ------------------------------------------------------------
-- customersï¼ˆé¡§å®¢ãƒ»å£°ç´‹è­˜åˆ¥ï¼‰
-- ğŸ†• æ–°è¦è¿½åŠ ï¼ˆ2025-12-06ï¼‰: å£°ç´‹è­˜åˆ¥æ©Ÿèƒ½ç”¨ãƒ†ãƒ¼ãƒ–ãƒ«
-- ------------------------------------------------------------
CREATE TABLE customers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  name VARCHAR(100),
  voice_embedding VECTOR(512),             -- å£°ç´‹åŸ‹ã‚è¾¼ã¿ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆpyannote 512æ¬¡å…ƒï¼‰
  embedding_updated_at TIMESTAMPTZ,
  total_visits INTEGER NOT NULL DEFAULT 1 CHECK (total_visits > 0),
  first_visit_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_visit_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_customers_salon_id ON customers(salon_id);
CREATE INDEX idx_customers_name ON customers(name) WHERE name IS NOT NULL;
CREATE INDEX idx_customers_last_visit ON customers(salon_id, last_visit_at DESC);

-- HNSWãƒ™ã‚¯ãƒˆãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆå£°ç´‹é¡ä¼¼æ¤œç´¢ç”¨ï¼‰
CREATE INDEX idx_customers_voice_embedding ON customers
  USING hnsw (voice_embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

CREATE TRIGGER update_customers_updated_at
  BEFORE UPDATE ON customers
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- sessionsãƒ†ãƒ¼ãƒ–ãƒ«ã«customer_idã‚’è¿½åŠ 
ALTER TABLE sessions
  ADD COLUMN customer_id UUID REFERENCES customers(id) ON DELETE SET NULL;

CREATE INDEX idx_sessions_customer_id ON sessions(customer_id);

-- ------------------------------------------------------------
-- training_scenariosï¼ˆãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚·ãƒŠãƒªã‚ªï¼‰
-- ã‚«ãƒ©ãƒ åã¯title/difficultyã§çµ±ä¸€ï¼ˆå®Ÿè£…ã¨ä¸€è‡´ï¼‰
-- ------------------------------------------------------------
CREATE TABLE training_scenarios (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID REFERENCES salons(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  customer_persona JSONB NOT NULL,
  objectives TEXT[] NOT NULL,
  difficulty TEXT NOT NULL DEFAULT 'beginner' CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  estimated_minutes INTEGER NOT NULL DEFAULT 10,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_training_scenarios_salon_id ON training_scenarios(salon_id);
CREATE INDEX idx_training_scenarios_difficulty ON training_scenarios(difficulty);
CREATE INDEX idx_training_scenarios_active ON training_scenarios(is_active);

-- ------------------------------------------------------------
-- roleplay_sessionsï¼ˆãƒ­ãƒ¼ãƒ«ãƒ—ãƒ¬ã‚¤ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼‰
-- ã‚«ãƒ©ãƒ åã¯messages/ended_atã§çµ±ä¸€ï¼ˆå®Ÿè£…ã¨ä¸€è‡´ï¼‰
-- ------------------------------------------------------------
CREATE TABLE roleplay_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  staff_id UUID NOT NULL REFERENCES staffs(id) ON DELETE CASCADE,
  scenario_id UUID NOT NULL REFERENCES training_scenarios(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned')),
  messages JSONB NOT NULL DEFAULT '[]'::jsonb,
  evaluation JSONB,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ
);

CREATE INDEX idx_roleplay_sessions_staff_id ON roleplay_sessions(staff_id);
CREATE INDEX idx_roleplay_sessions_scenario_id ON roleplay_sessions(scenario_id);
CREATE INDEX idx_roleplay_sessions_status ON roleplay_sessions(status);

-- ------------------------------------------------------------
-- audit_logsï¼ˆç›£æŸ»ãƒ­ã‚°ï¼‰
-- ------------------------------------------------------------
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type VARCHAR(50) NOT NULL,
  user_id UUID REFERENCES staffs(id),
  salon_id UUID REFERENCES salons(id),
  resource_type VARCHAR(50),
  resource_id UUID,
  action VARCHAR(20),
  old_value JSONB,
  new_value JSONB,
  ip_address INET,
  user_agent TEXT,
  request_id UUID,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_salon ON audit_logs(salon_id, created_at DESC);
CREATE INDEX idx_audit_logs_event ON audit_logs(event_type, created_at DESC);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);

-- è‡ªå‹•å‰Šé™¤ï¼ˆ90æ—¥çµŒéå¾Œï¼‰
CREATE OR REPLACE FUNCTION delete_old_audit_logs()
RETURNS void AS $$
BEGIN
  DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL '90 days';
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- RLSï¼ˆRow Level Securityï¼‰ãƒãƒªã‚·ãƒ¼
-- ============================================================

-- RLSæœ‰åŠ¹åŒ–
ALTER TABLE salons ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffs ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE transcripts ENABLE ROW LEVEL SECURITY;
ALTER TABLE speaker_segments ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_analyses ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE success_cases ENABLE ROW LEVEL SECURITY;
ALTER TABLE roleplay_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;

-- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
-- staffs.id = auth.users(id) æ§‹é€ ã®ãŸã‚ã€id = auth.uid() ã§æ¤œç´¢
CREATE OR REPLACE FUNCTION get_current_user_salon_id()
RETURNS UUID AS $$
  SELECT salon_id FROM staffs WHERE id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION get_current_user_role()
RETURNS staff_role AS $$
  SELECT role FROM staffs WHERE id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION get_current_user_staff_id()
RETURNS UUID AS $$
  SELECT id FROM staffs WHERE id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

-- salons ãƒãƒªã‚·ãƒ¼
CREATE POLICY "salon_select" ON salons
  FOR SELECT USING (id = get_current_user_salon_id());

CREATE POLICY "salon_update" ON salons
  FOR UPDATE USING (
    id = get_current_user_salon_id() 
    AND get_current_user_role() = 'owner'
  );

-- staffs ãƒãƒªã‚·ãƒ¼
CREATE POLICY "staff_select" ON staffs
  FOR SELECT USING (salon_id = get_current_user_salon_id());

CREATE POLICY "staff_insert" ON staffs
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "staff_update" ON staffs
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "staff_delete" ON staffs
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() = 'owner'
  );

-- sessions ãƒãƒªã‚·ãƒ¼
CREATE POLICY "session_select_own" ON sessions
  FOR SELECT USING (
    salon_id = get_current_user_salon_id()
    AND (
      stylist_id = get_current_user_staff_id()
      OR get_current_user_role() IN ('owner', 'manager')
    )
  );

CREATE POLICY "session_insert" ON sessions
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND stylist_id = get_current_user_staff_id()
    AND get_current_user_role() IN ('owner', 'manager', 'stylist')
  );

CREATE POLICY "session_update" ON sessions
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND stylist_id = get_current_user_staff_id()
  );

-- transcripts ãƒãƒªã‚·ãƒ¼
CREATE POLICY "transcript_all" ON transcripts
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- speaker_segments ãƒãƒªã‚·ãƒ¼
CREATE POLICY "speaker_segment_all" ON speaker_segments
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- session_analyses ãƒãƒªã‚·ãƒ¼
CREATE POLICY "analysis_all" ON session_analyses
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- session_reports ãƒãƒªã‚·ãƒ¼
CREATE POLICY "report_all" ON session_reports
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- success_cases ãƒãƒªã‚·ãƒ¼
CREATE POLICY "success_case_select" ON success_cases
  FOR SELECT USING (
    is_public = true
    OR salon_id = get_current_user_salon_id()
  );

CREATE POLICY "success_case_insert" ON success_cases
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "success_case_update" ON success_cases
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "success_case_delete" ON success_cases
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() = 'owner'
  );

-- roleplay_sessions ãƒãƒªã‚·ãƒ¼
CREATE POLICY "roleplay_select" ON roleplay_sessions
  FOR SELECT USING (
    staff_id = get_current_user_staff_id()
    OR get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "roleplay_insert" ON roleplay_sessions
  FOR INSERT WITH CHECK (
    staff_id = get_current_user_staff_id()
  );

CREATE POLICY "roleplay_update" ON roleplay_sessions
  FOR UPDATE USING (
    staff_id = get_current_user_staff_id()
  );

-- customers ãƒãƒªã‚·ãƒ¼
CREATE POLICY "customer_select" ON customers
  FOR SELECT USING (salon_id = get_current_user_salon_id());

CREATE POLICY "customer_insert" ON customers
  FOR INSERT WITH CHECK (salon_id = get_current_user_salon_id());

CREATE POLICY "customer_update" ON customers
  FOR UPDATE USING (salon_id = get_current_user_salon_id());

CREATE POLICY "customer_delete" ON customers
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

-- ============================================================
-- é–¢æ•°ãƒ»ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
-- ============================================================

-- ãƒ™ã‚¯ãƒˆãƒ«é¡ä¼¼æ¤œç´¢é–¢æ•°
CREATE OR REPLACE FUNCTION search_success_cases(
  query_embedding VECTOR(1536),
  match_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 5,
  p_salon_id UUID DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  concern_keywords TEXT[],
  successful_talk TEXT,
  key_tactics TEXT[],
  sold_product VARCHAR,
  similarity FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    sc.id,
    sc.concern_keywords,
    sc.successful_talk,
    sc.key_tactics,
    sc.sold_product,
    1 - (sc.embedding <=> query_embedding) AS similarity
  FROM success_cases sc
  WHERE
    sc.embedding IS NOT NULL
    AND (sc.is_public = true OR sc.salon_id = p_salon_id)
    AND 1 - (sc.embedding <=> query_embedding) > match_threshold
  ORDER BY sc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- ã‚¹ã‚¿ãƒƒãƒ•çµ±è¨ˆå–å¾—é–¢æ•°
CREATE OR REPLACE FUNCTION get_staff_statistics(
  p_staff_id UUID,
  p_start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '30 days',
  p_end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
  total_sessions BIGINT,
  avg_score NUMERIC,
  conversion_count BIGINT,
  conversion_rate NUMERIC,
  total_duration_minutes BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(DISTINCT s.id) AS total_sessions,
    COALESCE(ROUND(AVG(sr.overall_score), 1), 0) AS avg_score,
    COALESCE(
      SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END),
      0
    ) AS conversion_count,
    COALESCE(
      ROUND(
        SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END)::NUMERIC / 
        NULLIF(COUNT(DISTINCT s.id), 0) * 100,
        1
      ),
      0
    ) AS conversion_rate,
    COALESCE(
      SUM(EXTRACT(EPOCH FROM (s.ended_at - s.started_at)) / 60)::BIGINT,
      0
    ) AS total_duration_minutes
  FROM sessions s
  LEFT JOIN session_reports sr ON sr.session_id = s.id
  LEFT JOIN session_analyses sa ON sa.session_id = s.id AND sa.indicator_type = 'conversion'
  WHERE
    s.stylist_id = p_staff_id
    AND s.status = 'completed'
    AND s.started_at >= p_start_date
    AND s.started_at <= p_end_date;
END;
$$;

-- åº—èˆ—çµ±è¨ˆå–å¾—é–¢æ•°
CREATE OR REPLACE FUNCTION get_salon_statistics(
  p_salon_id UUID,
  p_start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '30 days',
  p_end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
  total_sessions BIGINT,
  avg_score NUMERIC,
  conversion_rate NUMERIC,
  active_stylists BIGINT,
  top_performer_id UUID,
  top_performer_name VARCHAR,
  top_performer_score NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH session_stats AS (
    SELECT
      s.stylist_id,
      COUNT(*) AS session_count,
      AVG(sr.overall_score) AS avg_score
    FROM sessions s
    LEFT JOIN session_reports sr ON sr.session_id = s.id
    WHERE
      s.salon_id = p_salon_id
      AND s.status = 'completed'
      AND s.started_at >= p_start_date
      AND s.started_at <= p_end_date
    GROUP BY s.stylist_id
  ),
  top_performer AS (
    SELECT
      st.id,
      st.name,
      ss.avg_score
    FROM session_stats ss
    JOIN staffs st ON st.id = ss.stylist_id
    ORDER BY ss.avg_score DESC NULLS LAST
    LIMIT 1
  )
  SELECT
    (SELECT COUNT(*) FROM sessions WHERE salon_id = p_salon_id AND status = 'completed' AND started_at >= p_start_date AND started_at <= p_end_date) AS total_sessions,
    (SELECT ROUND(AVG(sr.overall_score), 1) FROM sessions s JOIN session_reports sr ON sr.session_id = s.id WHERE s.salon_id = p_salon_id AND s.status = 'completed' AND s.started_at >= p_start_date AND s.started_at <= p_end_date) AS avg_score,
    (SELECT ROUND(
      SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END)::NUMERIC / 
      NULLIF(COUNT(DISTINCT s.id), 0) * 100, 1)
    FROM sessions s
    LEFT JOIN session_analyses sa ON sa.session_id = s.id AND sa.indicator_type = 'conversion'
    WHERE s.salon_id = p_salon_id AND s.status = 'completed' AND s.started_at >= p_start_date AND s.started_at <= p_end_date
    ) AS conversion_rate,
    (SELECT COUNT(DISTINCT stylist_id) FROM sessions WHERE salon_id = p_salon_id AND started_at >= p_start_date AND started_at <= p_end_date) AS active_stylists,
    tp.id AS top_performer_id,
    tp.name AS top_performer_name,
    ROUND(tp.avg_score, 1) AS top_performer_score
  FROM top_performer tp;
END;
$$;

-- ============================================================
-- å£°ç´‹è­˜åˆ¥é–¢æ•°
-- ============================================================

-- å£°ç´‹ã«ã‚ˆã‚‹é¡§å®¢ãƒãƒƒãƒãƒ³ã‚°é–¢æ•°
CREATE OR REPLACE FUNCTION match_customer_by_voice(
  query_embedding VECTOR(512),
  salon_id_param UUID,
  match_threshold FLOAT DEFAULT 0.65,
  match_count INT DEFAULT 5
)
RETURNS TABLE (
  id UUID,
  name VARCHAR,
  similarity FLOAT,
  total_visits INTEGER,
  last_visit_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id,
    c.name,
    1 - (c.voice_embedding <=> query_embedding) AS similarity,
    c.total_visits,
    c.last_visit_at
  FROM customers c
  WHERE
    c.salon_id = salon_id_param
    AND c.voice_embedding IS NOT NULL
    AND 1 - (c.voice_embedding <=> query_embedding) > match_threshold
  ORDER BY c.voice_embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- é¡§å®¢ã®å£°ç´‹åŸ‹ã‚è¾¼ã¿æ›´æ–°é–¢æ•°ï¼ˆåŠ é‡å¹³å‡ï¼‰
CREATE OR REPLACE FUNCTION update_customer_embedding(
  customer_id_param UUID,
  new_embedding VECTOR(512)
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  current_visits INTEGER;
  current_embedding VECTOR(512);
  weight FLOAT;
BEGIN
  -- ç¾åœ¨ã®è¨ªå•å›æ•°ã¨åŸ‹ã‚è¾¼ã¿ã‚’å–å¾—
  SELECT total_visits, voice_embedding
  INTO current_visits, current_embedding
  FROM customers
  WHERE id = customer_id_param;

  IF current_embedding IS NULL THEN
    -- åˆå›ã®å ´åˆã¯ãã®ã¾ã¾è¨­å®š
    UPDATE customers
    SET
      voice_embedding = new_embedding,
      embedding_updated_at = NOW(),
      total_visits = current_visits + 1,
      last_visit_at = NOW(),
      updated_at = NOW()
    WHERE id = customer_id_param;
  ELSE
    -- åŠ é‡å¹³å‡ã§æ›´æ–°ï¼ˆæ–°ã—ã„åŸ‹ã‚è¾¼ã¿ã®é‡ã¿ã‚’è¨ˆç®—ï¼‰
    -- é‡ã¿ = 1 / (total_visits + 1)ã€æœ€å¤§0.3
    weight := LEAST(1.0 / (current_visits + 1), 0.3);

    UPDATE customers
    SET
      voice_embedding = (
        (1 - weight) * current_embedding::vector + weight * new_embedding::vector
      )::VECTOR(512),
      embedding_updated_at = NOW(),
      total_visits = current_visits + 1,
      last_visit_at = NOW(),
      updated_at = NOW()
    WHERE id = customer_id_param;
  END IF;
END;
$$;

-- é¡§å®¢ä½œæˆé–¢æ•°ï¼ˆå£°ç´‹ä»˜ãï¼‰
CREATE OR REPLACE FUNCTION create_customer_with_embedding(
  salon_id_param UUID,
  name_param VARCHAR DEFAULT NULL,
  embedding_param VECTOR(512) DEFAULT NULL,
  metadata_param JSONB DEFAULT '{}'::jsonb
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_customer_id UUID;
BEGIN
  INSERT INTO customers (
    salon_id,
    name,
    voice_embedding,
    embedding_updated_at,
    metadata
  ) VALUES (
    salon_id_param,
    name_param,
    embedding_param,
    CASE WHEN embedding_param IS NOT NULL THEN NOW() ELSE NULL END,
    metadata_param
  )
  RETURNING id INTO new_customer_id;

  RETURN new_customer_id;
END;
$$;
```

### 7.2 ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆ

#### 7.2.1 ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä¸€è¦§

| ãƒ†ãƒ¼ãƒ–ãƒ« | ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å | ã‚«ãƒ©ãƒ  | ç¨®åˆ¥ | ç”¨é€” |
|---------|--------------|--------|------|------|
| salons | idx_salons_plan | plan | B-tree | ãƒ—ãƒ©ãƒ³åˆ¥æ¤œç´¢ |
| staffs | idx_staffs_salon_id | salon_id | B-tree | åº—èˆ—åˆ¥ã‚¹ã‚¿ãƒƒãƒ•å–å¾— |
| staffs | idx_staffs_role | role | B-tree | ãƒ­ãƒ¼ãƒ«åˆ¥æ¤œç´¢ |
| staffs | idx_staffs_salon_active | salon_id, is_active | B-tree (éƒ¨åˆ†) | ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¹ã‚¿ãƒƒãƒ•å–å¾— |
| sessions | idx_sessions_salon_started | salon_id, started_at | B-tree | åº—èˆ—åˆ¥ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ |
| sessions | idx_sessions_stylist_started | stylist_id, started_at | B-tree | ã‚¹ã‚¿ã‚¤ãƒªã‚¹ãƒˆåˆ¥å±¥æ­´ |
| sessions | idx_sessions_active | stylist_id, status | B-tree (éƒ¨åˆ†) | ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒƒã‚·ãƒ§ãƒ³æ¤œç´¢ |
| transcripts | idx_transcripts_session_chunk | session_id, chunk_index | B-tree | ãƒãƒ£ãƒ³ã‚¯é †å–å¾— |
| speaker_segments | idx_speaker_segments_session_time | session_id, start_time_ms | B-tree | æ™‚ç³»åˆ—å–å¾— |
| session_analyses | idx_session_analyses_session_indicator | session_id, indicator_type | B-tree | æŒ‡æ¨™åˆ¥åˆ†æå–å¾— |
| session_reports | idx_session_reports_score | overall_score | B-tree (DESC) | ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚° |
| success_cases | idx_success_cases_concern | concern_keywords | GIN | ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢ |
| success_cases | idx_success_cases_embedding | embedding | HNSW | ãƒ™ã‚¯ãƒˆãƒ«é¡ä¼¼æ¤œç´¢ |
| customers | idx_customers_salon_id | salon_id | B-tree | åº—èˆ—åˆ¥é¡§å®¢å–å¾— |
| customers | idx_customers_name | name | B-tree (éƒ¨åˆ†) | åå‰æ¤œç´¢ï¼ˆNULLé™¤å¤–ï¼‰ |
| customers | idx_customers_last_visit | salon_id, last_visit_at | B-tree | æœ€çµ‚è¨ªå•é †å–å¾— |
| customers | idx_customers_voice_embedding | voice_embedding | HNSW | å£°ç´‹é¡ä¼¼æ¤œç´¢ |
| sessions | idx_sessions_customer_id | customer_id | B-tree | é¡§å®¢åˆ¥ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾— |

#### 7.2.2 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°è¨­å®š

```sql
-- PostgreSQLè¨­å®šæ¨å¥¨å€¤ï¼ˆSupabase Proä»¥ä¸Šï¼‰

-- shared_buffers: ãƒ¡ãƒ¢ãƒªã®25%ç¨‹åº¦
-- effective_cache_size: ãƒ¡ãƒ¢ãƒªã®75%ç¨‹åº¦
-- work_mem: 64MBï¼ˆè¤‡é›‘ãªã‚½ãƒ¼ãƒˆãƒ»é›†è¨ˆç”¨ï¼‰
-- maintenance_work_mem: 512MBï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆç”¨ï¼‰

-- HNSWã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æ¤œç´¢ç²¾åº¦è¨­å®š
SET hnsw.ef_search = 100;  -- æ¤œç´¢æ™‚ã®æ¢ç´¢ç¯„å›²ï¼ˆå¤§ãã„ã»ã©ç²¾åº¦â†‘ã€é€Ÿåº¦â†“ï¼‰

-- çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
ANALYZE salons;
ANALYZE staffs;
ANALYZE sessions;
ANALYZE transcripts;
ANALYZE speaker_segments;
ANALYZE session_analyses;
ANALYZE session_reports;
ANALYZE success_cases;
ANALYZE customers;
```

---
