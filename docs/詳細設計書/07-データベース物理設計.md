## 7. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç‰©ç†è¨­è¨ˆ

### 7.1 ç‰©ç†ã‚¹ã‚­ãƒ¼ãƒå®šç¾©

#### 7.1.1 å®Œå…¨ãªDDLï¼ˆData Definition Languageï¼‰

```sql
-- ============================================================
-- SalonTalk AI ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç‰©ç†è¨­è¨ˆ
-- PostgreSQL 15+ / Supabase
-- ============================================================

-- ============================================================
-- æ‹¡å¼µæ©Ÿèƒ½ã®æœ‰åŠ¹åŒ–
-- ============================================================

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
CREATE EXTENSION IF NOT EXISTS "vector";

-- ============================================================
-- ã‚«ã‚¹ã‚¿ãƒ å‹å®šç¾©
-- ============================================================
-- âš ï¸ å®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£ï¼ˆ2025-12-05ï¼‰

-- ãƒ—ãƒ©ãƒ³ç¨®åˆ¥ï¼ˆå®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£: freeè¿½åŠ ã€professionalâ†’premiumï¼‰
CREATE TYPE plan_type AS ENUM ('free', 'standard', 'premium', 'enterprise');

-- ã‚¹ã‚¿ãƒƒãƒ•ãƒ­ãƒ¼ãƒ«ï¼ˆå®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£: assistantâ†’adminï¼‰
CREATE TYPE staff_role AS ENUM ('owner', 'manager', 'stylist', 'admin');

-- ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼ˆå®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£: analyzingè¿½åŠ ã€failedâ†’errorï¼‰
CREATE TYPE session_status AS ENUM ('recording', 'processing', 'analyzing', 'completed', 'error');

-- è©±è€…åˆ†é›¢ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
CREATE TYPE diarization_status AS ENUM ('pending', 'processing', 'completed', 'failed');

-- è©±è€…
CREATE TYPE speaker_type AS ENUM ('stylist', 'customer', 'unknown');

-- åˆ†ææŒ‡æ¨™ã‚¿ã‚¤ãƒ—
CREATE TYPE indicator_type AS ENUM (
  'talk_ratio',
  'question_analysis',
  'emotion_analysis',
  'concern_keywords',
  'proposal_timing',
  'proposal_quality',
  'conversion'
);

-- ============================================================
-- ãƒ†ãƒ¼ãƒ–ãƒ«å®šç¾©
-- ============================================================

-- ------------------------------------------------------------
-- salonsï¼ˆåº—èˆ—ï¼‰
-- ------------------------------------------------------------
CREATE TABLE salons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  address TEXT,
  phone VARCHAR(20),
  plan plan_type NOT NULL DEFAULT 'standard',
  seats_count INTEGER CHECK (seats_count IS NULL OR seats_count > 0),
  settings JSONB NOT NULL DEFAULT '{
    "notification": {
      "enablePush": true,
      "enableEmail": true,
      "concernDetectionAlert": true,
      "sessionCompleteAlert": true
    },
    "analysis": {
      "idealTalkRatio": 40,
      "minQuestionCount": 8,
      "concernKeywords": ["ä¹¾ç‡¥", "åºƒãŒã‚Š", "ãƒ‘ã‚µã¤ã", "ãƒ€ãƒ¡ãƒ¼ã‚¸", "ã†ã­ã‚Š", "è–„æ¯›", "ç™½é«ª"]
    },
    "display": {
      "showRanking": true,
      "anonymizeCustomer": false
    }
  }'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_salons_plan ON salons(plan);
CREATE INDEX idx_salons_created_at ON salons(created_at);

-- æ›´æ–°æ—¥æ™‚è‡ªå‹•æ›´æ–°ãƒˆãƒªã‚¬ãƒ¼
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_salons_updated_at
  BEFORE UPDATE ON salons
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- staffsï¼ˆã‚¹ã‚¿ãƒƒãƒ•ï¼‰
-- âš ï¸ å®Ÿè£…ã«åˆã‚ã›ã¦ä¿®æ­£ï¼ˆ2025-12-05ï¼‰: id=auth.users(id)æ§‹é€ 
-- ğŸ†• æ›´æ–°ï¼ˆ2025-12-09ï¼‰: voice_embeddingè¿½åŠ ï¼ˆã‚¹ã‚¿ãƒƒãƒ•å£°ç´‹è­˜åˆ¥ç”¨ï¼‰
-- ------------------------------------------------------------
CREATE TABLE staffs (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  name VARCHAR(50) NOT NULL,
  email VARCHAR(255) NOT NULL,
  role staff_role NOT NULL DEFAULT 'stylist',
  avatar_url TEXT,
  voice_embedding VECTOR(512),           -- ğŸ†• å£°ç´‹åŸ‹ã‚è¾¼ã¿ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆpyannote 512æ¬¡å…ƒï¼‰
  voice_registered_at TIMESTAMPTZ,       -- ğŸ†• å£°ç´‹ç™»éŒ²æ—¥æ™‚
  voice_sample_count INTEGER DEFAULT 0,  -- ğŸ†• å£°ç´‹ã‚µãƒ³ãƒ—ãƒ«æ•°ï¼ˆå“è³ªå‘ä¸Šç”¨ï¼‰
  is_active BOOLEAN NOT NULL DEFAULT true,
  setup_completed BOOLEAN NOT NULL DEFAULT false, -- ğŸ†• åˆå›ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ãƒ•ãƒ©ã‚°
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT staffs_email_unique UNIQUE (email)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_staffs_salon_id ON staffs(salon_id);
CREATE INDEX idx_staffs_role ON staffs(role);
CREATE INDEX idx_staffs_is_active ON staffs(is_active);
CREATE INDEX idx_staffs_salon_active ON staffs(salon_id, is_active) WHERE is_active = true;

-- ğŸ†• HNSWãƒ™ã‚¯ãƒˆãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆã‚¹ã‚¿ãƒƒãƒ•å£°ç´‹æ¤œç´¢ç”¨ï¼‰
CREATE INDEX idx_staffs_voice_embedding ON staffs
  USING hnsw (voice_embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

CREATE TRIGGER update_staffs_updated_at
  BEFORE UPDATE ON staffs
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- devicesï¼ˆãƒ‡ãƒã‚¤ã‚¹ / iPadï¼‰
-- ğŸ†• æ–°è¦è¿½åŠ ï¼ˆ2025-12-09ï¼‰: ãƒ‡ãƒã‚¤ã‚¹ç®¡ç†æ©Ÿèƒ½ç”¨ãƒ†ãƒ¼ãƒ–ãƒ«
-- ------------------------------------------------------------

-- ãƒ‡ãƒã‚¤ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
CREATE TYPE device_status AS ENUM ('pending', 'active', 'inactive', 'revoked');

CREATE TABLE devices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  device_name VARCHAR(100) NOT NULL,              -- è¡¨ç¤ºåï¼ˆä¾‹: "ã‚»ãƒƒãƒˆé¢1 iPad"ï¼‰
  device_identifier VARCHAR(255),                 -- ãƒ‡ãƒã‚¤ã‚¹å›ºæœ‰IDï¼ˆUDIDç­‰ï¼‰
  status device_status NOT NULL DEFAULT 'pending',
  seat_number INTEGER,                            -- ã‚»ãƒƒãƒˆé¢ç•ªå·ï¼ˆä»»æ„ï¼‰
  last_active_at TIMESTAMPTZ,                     -- æœ€çµ‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ—¥æ™‚
  activated_at TIMESTAMPTZ,                       -- ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³æ—¥æ™‚
  activated_by UUID REFERENCES staffs(id),        -- ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œè€…
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,    -- ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±ï¼ˆOS versionç­‰ï¼‰
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT devices_salon_name_unique UNIQUE (salon_id, device_name)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_devices_salon_id ON devices(salon_id);
CREATE INDEX idx_devices_status ON devices(status);
CREATE INDEX idx_devices_salon_active ON devices(salon_id, status) WHERE status = 'active';

-- ğŸ†• 2025-12-09è¿½åŠ : device_identifierä¸€æ„åˆ¶ç´„
ALTER TABLE devices
  ADD CONSTRAINT devices_identifier_unique UNIQUE (device_identifier);

-- ğŸ†• 2025-12-09è¿½åŠ : æœ€çµ‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ—¥æ™‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_devices_last_active ON devices(last_active_at DESC NULLS LAST);

CREATE TRIGGER update_devices_updated_at
  BEFORE UPDATE ON devices
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- device_seat_historyï¼ˆãƒ‡ãƒã‚¤ã‚¹åº§å¸­å¤‰æ›´å±¥æ­´ï¼‰
-- ğŸ†• æ–°è¦è¿½åŠ ï¼ˆ2025-12-09ï¼‰: åº§å¸­ç•ªå·å¤‰æ›´ã®ç›£æŸ»ãƒ­ã‚°
-- ------------------------------------------------------------
CREATE TABLE device_seat_history (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  device_id UUID NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
  previous_seat_number INTEGER,                    -- å¤‰æ›´å‰ã®åº§å¸­ç•ªå·ï¼ˆNULL=æœªè¨­å®šã‹ã‚‰å¤‰æ›´ï¼‰
  new_seat_number INTEGER,                         -- å¤‰æ›´å¾Œã®åº§å¸­ç•ªå·ï¼ˆNULL=åº§å¸­ç•ªå·ã‚’å‰Šé™¤ï¼‰
  changed_by UUID REFERENCES staffs(id) ON DELETE SET NULL, -- å¤‰æ›´å®Ÿè¡Œè€…
  changed_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),   -- å¤‰æ›´æ—¥æ™‚
  reason TEXT                                      -- å¤‰æ›´ç†ç”±ï¼ˆä»»æ„ï¼‰
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_device_seat_history_device_id ON device_seat_history(device_id);
CREATE INDEX idx_device_seat_history_changed_at ON device_seat_history(changed_at DESC);

-- åº§å¸­ç•ªå·å¤‰æ›´æ™‚ã®è‡ªå‹•å±¥æ­´è¨˜éŒ²ãƒˆãƒªã‚¬ãƒ¼
CREATE OR REPLACE FUNCTION record_seat_change()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.seat_number IS DISTINCT FROM NEW.seat_number THEN
    INSERT INTO device_seat_history (device_id, previous_seat_number, new_seat_number)
    VALUES (NEW.id, OLD.seat_number, NEW.seat_number);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_record_seat_change
  AFTER UPDATE ON devices
  FOR EACH ROW
  EXECUTE FUNCTION record_seat_change();

-- ------------------------------------------------------------
-- device_activationsï¼ˆãƒ‡ãƒã‚¤ã‚¹ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ï¼‰
-- ğŸ†• æ–°è¦è¿½åŠ ï¼ˆ2025-12-09ï¼‰: 6æ¡ã‚³ãƒ¼ãƒ‰ã«ã‚ˆã‚‹ãƒ‡ãƒã‚¤ã‚¹èªè¨¼
-- ------------------------------------------------------------
CREATE TABLE device_activations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  device_id UUID NOT NULL REFERENCES devices(id) ON DELETE CASCADE,
  activation_code CHAR(6) NOT NULL,               -- 6æ¡æ•°å­—ã®ã¿ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰
  expires_at TIMESTAMPTZ NOT NULL,                -- æœ‰åŠ¹æœŸé™ï¼ˆç™ºè¡Œã‹ã‚‰24æ™‚é–“ï¼‰
  used_at TIMESTAMPTZ,                            -- ä½¿ç”¨æ—¥æ™‚
  created_by UUID NOT NULL REFERENCES staffs(id), -- ã‚³ãƒ¼ãƒ‰ç™ºè¡Œè€…
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- ğŸ†• 2025-12-09è¿½åŠ : æ•°å­—6æ¡ã®ã¿è¨±å¯
  CONSTRAINT device_activations_code_numeric CHECK (activation_code ~ '^[0-9]{6}$'),
  CONSTRAINT device_activations_not_expired CHECK (expires_at > created_at)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_device_activations_device_id ON device_activations(device_id);
CREATE INDEX idx_device_activations_expires ON device_activations(expires_at) WHERE used_at IS NULL;

-- ğŸ†• 2025-12-09è¿½åŠ : æœªä½¿ç”¨ã‚³ãƒ¼ãƒ‰ã®ä¸€æ„åˆ¶ç´„ï¼ˆéƒ¨åˆ†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
CREATE UNIQUE INDEX idx_device_activations_code_unique
  ON device_activations(activation_code)
  WHERE used_at IS NULL;

-- ------------------------------------------------------------
-- sessionsï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼‰
-- ğŸ†• æ›´æ–°ï¼ˆ2025-12-09ï¼‰: device_idè¿½åŠ ã€stylist_id NULLableï¼ˆè‡ªå‹•è­˜åˆ¥å¯¾å¿œï¼‰
-- ------------------------------------------------------------
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  device_id UUID REFERENCES devices(id) ON DELETE SET NULL, -- ğŸ†• ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ãƒ‡ãƒã‚¤ã‚¹
  stylist_id UUID REFERENCES staffs(id) ON DELETE CASCADE,  -- ğŸ†• NULLableï¼ˆå£°ç´‹è­˜åˆ¥å¾Œã«è¨­å®šï¼‰
  stylist_match_confidence REAL,                            -- ğŸ†• ã‚¹ã‚¿ãƒƒãƒ•å£°ç´‹ãƒãƒƒãƒãƒ³ã‚°ä¿¡é ¼åº¦
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ,
  status session_status NOT NULL DEFAULT 'recording',
  customer_info JSONB,
  diarization_status diarization_status NOT NULL DEFAULT 'pending',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT sessions_end_after_start CHECK (ended_at IS NULL OR ended_at >= started_at)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_sessions_salon_id ON sessions(salon_id);
CREATE INDEX idx_sessions_device_id ON sessions(device_id);
CREATE INDEX idx_sessions_stylist_id ON sessions(stylist_id);
CREATE INDEX idx_sessions_status ON sessions(status);
CREATE INDEX idx_sessions_started_at ON sessions(started_at DESC);
CREATE INDEX idx_sessions_salon_started ON sessions(salon_id, started_at DESC);
CREATE INDEX idx_sessions_stylist_started ON sessions(stylist_id, started_at DESC);
CREATE INDEX idx_sessions_active ON sessions(device_id, status) WHERE status = 'recording';

-- æœˆåˆ¥ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³ç”¨ï¼ˆå°†æ¥æ‹¡å¼µï¼‰
-- CREATE INDEX idx_sessions_started_month ON sessions(date_trunc('month', started_at));

CREATE TRIGGER update_sessions_updated_at
  BEFORE UPDATE ON sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ------------------------------------------------------------
-- transcriptsï¼ˆæ–‡å­—èµ·ã“ã—ï¼‰
-- æ™‚é–“å˜ä½ã¯ãƒŸãƒªç§’ã§çµ±ä¸€ï¼ˆspeaker_segmentsã¨ä¸€è‡´ï¼‰
-- ------------------------------------------------------------
CREATE TABLE transcripts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  text TEXT NOT NULL,
  start_time_ms INTEGER NOT NULL,
  end_time_ms INTEGER NOT NULL,
  audio_url TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT transcripts_session_chunk_unique UNIQUE (session_id, chunk_index),
  CONSTRAINT transcripts_time_valid CHECK (end_time_ms > start_time_ms)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_transcripts_session_id ON transcripts(session_id);
CREATE INDEX idx_transcripts_session_chunk ON transcripts(session_id, chunk_index);

-- ------------------------------------------------------------
-- speaker_segmentsï¼ˆè©±è€…ã‚»ã‚°ãƒ¡ãƒ³ãƒˆï¼‰
-- æ™‚é–“å˜ä½ã¯ãƒŸãƒªç§’ã§çµ±ä¸€ï¼ˆtranscriptsã¨ä¸€è‡´ï¼‰
-- ------------------------------------------------------------
CREATE TABLE speaker_segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  speaker speaker_type NOT NULL,
  start_time_ms INTEGER NOT NULL,
  end_time_ms INTEGER NOT NULL,
  text TEXT,
  confidence NUMERIC(5, 4) CHECK (confidence IS NULL OR (confidence >= 0 AND confidence <= 1)),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CONSTRAINT speaker_segments_time_valid CHECK (end_time_ms > start_time_ms)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_speaker_segments_session_id ON speaker_segments(session_id);
CREATE INDEX idx_speaker_segments_speaker ON speaker_segments(speaker);
CREATE INDEX idx_speaker_segments_session_time ON speaker_segments(session_id, start_time_ms);

-- ------------------------------------------------------------
-- session_analysesï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³åˆ†æï¼‰
-- ------------------------------------------------------------
CREATE TABLE session_analyses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE,
  chunk_index INTEGER NOT NULL,
  indicator_type indicator_type NOT NULL,
  value NUMERIC(10, 4) NOT NULL,
  score INTEGER NOT NULL CHECK (score >= 0 AND score <= 100),
  details JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  
  CONSTRAINT session_analyses_unique UNIQUE (session_id, chunk_index, indicator_type)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_session_analyses_session_id ON session_analyses(session_id);
CREATE INDEX idx_session_analyses_indicator ON session_analyses(indicator_type);
CREATE INDEX idx_session_analyses_session_chunk ON session_analyses(session_id, chunk_index);
CREATE INDEX idx_session_analyses_session_indicator ON session_analyses(session_id, indicator_type);

-- ------------------------------------------------------------
-- session_reportsï¼ˆã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ¬ãƒãƒ¼ãƒˆï¼‰
-- ã‚«ãƒ©ãƒ åã¯å®Ÿè£…ã¨ä¸€è‡´: summary, strengths, improvements, metrics
-- ------------------------------------------------------------
CREATE TABLE session_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES sessions(id) ON DELETE CASCADE UNIQUE,
  summary TEXT NOT NULL,
  overall_score INTEGER NOT NULL CHECK (overall_score >= 0 AND overall_score <= 100),
  metrics JSONB NOT NULL DEFAULT '{}',
  stylist_ratio INTEGER,
  customer_ratio INTEGER,
  open_question_count INTEGER DEFAULT 0,
  closed_question_count INTEGER DEFAULT 0,
  positive_ratio INTEGER,
  concern_keywords TEXT[] DEFAULT '{}',
  proposal_timing_ms INTEGER,
  proposal_match_rate INTEGER,
  is_converted BOOLEAN DEFAULT FALSE,
  improvements TEXT[] DEFAULT '{}',
  strengths TEXT[] DEFAULT '{}',
  matched_cases JSONB DEFAULT '[]',
  generated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_session_reports_session_id ON session_reports(session_id);
CREATE INDEX idx_session_reports_score ON session_reports(overall_score DESC);
CREATE INDEX idx_session_reports_created_at ON session_reports(created_at DESC);

-- ------------------------------------------------------------
-- success_casesï¼ˆæˆåŠŸäº‹ä¾‹ï¼‰
-- ã‚«ãƒ©ãƒ åã¯å®Ÿè£…ã¨ä¸€è‡´: approach_text, result, is_activeè¿½åŠ 
-- ------------------------------------------------------------
CREATE TABLE success_cases (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  session_id UUID REFERENCES sessions(id) ON DELETE SET NULL,
  stylist_id UUID REFERENCES staffs(id) ON DELETE SET NULL,
  concern_keywords TEXT[] NOT NULL,
  customer_profile JSONB,
  approach_text TEXT NOT NULL,
  successful_talk TEXT,
  key_tactics TEXT[],
  result TEXT NOT NULL,
  sold_product TEXT,
  conversion_rate REAL,
  embedding VECTOR(1536),
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  is_public BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_success_cases_salon_id ON success_cases(salon_id);
CREATE INDEX idx_success_cases_is_public ON success_cases(is_public);
CREATE INDEX idx_success_cases_concern ON success_cases USING GIN(concern_keywords);
CREATE INDEX idx_success_cases_created_at ON success_cases(created_at DESC);

-- HNSWãƒ™ã‚¯ãƒˆãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆé«˜é€Ÿè¿‘ä¼¼æœ€è¿‘å‚æ¢ç´¢ï¼‰
CREATE INDEX idx_success_cases_embedding ON success_cases
  USING hnsw (embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- ------------------------------------------------------------
-- customersï¼ˆé¡§å®¢ãƒ»å£°ç´‹è­˜åˆ¥ï¼‰
-- ğŸ†• æ–°è¦è¿½åŠ ï¼ˆ2025-12-06ï¼‰: å£°ç´‹è­˜åˆ¥æ©Ÿèƒ½ç”¨ãƒ†ãƒ¼ãƒ–ãƒ«
-- ------------------------------------------------------------
CREATE TABLE customers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID NOT NULL REFERENCES salons(id) ON DELETE CASCADE,
  name VARCHAR(100),
  voice_embedding VECTOR(512),             -- å£°ç´‹åŸ‹ã‚è¾¼ã¿ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆpyannote 512æ¬¡å…ƒï¼‰
  embedding_updated_at TIMESTAMPTZ,
  total_visits INTEGER NOT NULL DEFAULT 1 CHECK (total_visits > 0),
  first_visit_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_visit_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_customers_salon_id ON customers(salon_id);
CREATE INDEX idx_customers_name ON customers(name) WHERE name IS NOT NULL;
CREATE INDEX idx_customers_last_visit ON customers(salon_id, last_visit_at DESC);

-- HNSWãƒ™ã‚¯ãƒˆãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆå£°ç´‹é¡ä¼¼æ¤œç´¢ç”¨ï¼‰
CREATE INDEX idx_customers_voice_embedding ON customers
  USING hnsw (voice_embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

CREATE TRIGGER update_customers_updated_at
  BEFORE UPDATE ON customers
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- sessionsãƒ†ãƒ¼ãƒ–ãƒ«ã«customer_idã‚’è¿½åŠ 
ALTER TABLE sessions
  ADD COLUMN customer_id UUID REFERENCES customers(id) ON DELETE SET NULL;

CREATE INDEX idx_sessions_customer_id ON sessions(customer_id);

-- ------------------------------------------------------------
-- training_scenariosï¼ˆãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°ã‚·ãƒŠãƒªã‚ªï¼‰
-- ã‚«ãƒ©ãƒ åã¯title/difficultyã§çµ±ä¸€ï¼ˆå®Ÿè£…ã¨ä¸€è‡´ï¼‰
-- ------------------------------------------------------------
CREATE TABLE training_scenarios (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  salon_id UUID REFERENCES salons(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  customer_persona JSONB NOT NULL,
  objectives TEXT[] NOT NULL,
  difficulty TEXT NOT NULL DEFAULT 'beginner' CHECK (difficulty IN ('beginner', 'intermediate', 'advanced')),
  estimated_minutes INTEGER NOT NULL DEFAULT 10,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_training_scenarios_salon_id ON training_scenarios(salon_id);
CREATE INDEX idx_training_scenarios_difficulty ON training_scenarios(difficulty);
CREATE INDEX idx_training_scenarios_active ON training_scenarios(is_active);

-- ------------------------------------------------------------
-- roleplay_sessionsï¼ˆãƒ­ãƒ¼ãƒ«ãƒ—ãƒ¬ã‚¤ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼‰
-- ã‚«ãƒ©ãƒ åã¯messages/ended_atã§çµ±ä¸€ï¼ˆå®Ÿè£…ã¨ä¸€è‡´ï¼‰
-- ------------------------------------------------------------
CREATE TABLE roleplay_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  staff_id UUID NOT NULL REFERENCES staffs(id) ON DELETE CASCADE,
  scenario_id UUID NOT NULL REFERENCES training_scenarios(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned')),
  messages JSONB NOT NULL DEFAULT '[]'::jsonb,
  evaluation JSONB,
  started_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ended_at TIMESTAMPTZ
);

CREATE INDEX idx_roleplay_sessions_staff_id ON roleplay_sessions(staff_id);
CREATE INDEX idx_roleplay_sessions_scenario_id ON roleplay_sessions(scenario_id);
CREATE INDEX idx_roleplay_sessions_status ON roleplay_sessions(status);

-- ------------------------------------------------------------
-- audit_logsï¼ˆç›£æŸ»ãƒ­ã‚°ï¼‰
-- ------------------------------------------------------------
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  event_type VARCHAR(50) NOT NULL,
  user_id UUID REFERENCES staffs(id),
  salon_id UUID REFERENCES salons(id),
  resource_type VARCHAR(50),
  resource_id UUID,
  action VARCHAR(20),
  old_value JSONB,
  new_value JSONB,
  ip_address INET,
  user_agent TEXT,
  request_id UUID,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_audit_logs_user ON audit_logs(user_id, created_at DESC);
CREATE INDEX idx_audit_logs_salon ON audit_logs(salon_id, created_at DESC);
CREATE INDEX idx_audit_logs_event ON audit_logs(event_type, created_at DESC);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at DESC);

-- è‡ªå‹•å‰Šé™¤ï¼ˆ90æ—¥çµŒéå¾Œï¼‰
CREATE OR REPLACE FUNCTION delete_old_audit_logs()
RETURNS void AS $$
BEGIN
  DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL '90 days';
END;
$$ LANGUAGE plpgsql;

-- ============================================================
-- RLSï¼ˆRow Level Securityï¼‰ãƒãƒªã‚·ãƒ¼
-- ============================================================

-- RLSæœ‰åŠ¹åŒ–
ALTER TABLE salons ENABLE ROW LEVEL SECURITY;
ALTER TABLE staffs ENABLE ROW LEVEL SECURITY;
ALTER TABLE devices ENABLE ROW LEVEL SECURITY;
ALTER TABLE device_activations ENABLE ROW LEVEL SECURITY;
ALTER TABLE device_seat_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE transcripts ENABLE ROW LEVEL SECURITY;
ALTER TABLE speaker_segments ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_analyses ENABLE ROW LEVEL SECURITY;
ALTER TABLE session_reports ENABLE ROW LEVEL SECURITY;
ALTER TABLE success_cases ENABLE ROW LEVEL SECURITY;
ALTER TABLE roleplay_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;

-- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
-- staffs.id = auth.users(id) æ§‹é€ ã®ãŸã‚ã€id = auth.uid() ã§æ¤œç´¢
CREATE OR REPLACE FUNCTION get_current_user_salon_id()
RETURNS UUID AS $$
  SELECT salon_id FROM staffs WHERE id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION get_current_user_role()
RETURNS staff_role AS $$
  SELECT role FROM staffs WHERE id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

CREATE OR REPLACE FUNCTION get_current_user_staff_id()
RETURNS UUID AS $$
  SELECT id FROM staffs WHERE id = auth.uid()
$$ LANGUAGE sql SECURITY DEFINER STABLE;

-- salons ãƒãƒªã‚·ãƒ¼
CREATE POLICY "salon_select" ON salons
  FOR SELECT USING (id = get_current_user_salon_id());

CREATE POLICY "salon_update" ON salons
  FOR UPDATE USING (
    id = get_current_user_salon_id() 
    AND get_current_user_role() = 'owner'
  );

-- staffs ãƒãƒªã‚·ãƒ¼
CREATE POLICY "staff_select" ON staffs
  FOR SELECT USING (salon_id = get_current_user_salon_id());

CREATE POLICY "staff_insert" ON staffs
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "staff_update" ON staffs
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "staff_delete" ON staffs
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() = 'owner'
  );

-- ğŸ†• devices ãƒãƒªã‚·ãƒ¼ï¼ˆ2025-12-09è¿½åŠ ï¼‰
CREATE POLICY "device_select" ON devices
  FOR SELECT USING (salon_id = get_current_user_salon_id());

CREATE POLICY "device_insert" ON devices
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "device_update" ON devices
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "device_delete" ON devices
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() = 'owner'
  );

-- ğŸ†• device_activations ãƒãƒªã‚·ãƒ¼ï¼ˆ2025-12-09è¿½åŠ ï¼‰
CREATE POLICY "device_activation_select" ON device_activations
  FOR SELECT USING (
    device_id IN (
      SELECT id FROM devices WHERE salon_id = get_current_user_salon_id()
    )
  );

CREATE POLICY "device_activation_insert" ON device_activations
  FOR INSERT WITH CHECK (
    device_id IN (
      SELECT id FROM devices WHERE salon_id = get_current_user_salon_id()
    )
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "device_activation_update" ON device_activations
  FOR UPDATE USING (
    device_id IN (
      SELECT id FROM devices WHERE salon_id = get_current_user_salon_id()
    )
    AND get_current_user_role() IN ('owner', 'manager')
  );

-- ğŸ†• device_seat_history ãƒãƒªã‚·ãƒ¼ï¼ˆ2025-12-09è¿½åŠ ï¼‰
CREATE POLICY "device_seat_history_select" ON device_seat_history
  FOR SELECT USING (
    device_id IN (
      SELECT id FROM devices WHERE salon_id = get_current_user_salon_id()
    )
  );

CREATE POLICY "device_seat_history_insert" ON device_seat_history
  FOR INSERT WITH CHECK (
    device_id IN (
      SELECT id FROM devices WHERE salon_id = get_current_user_salon_id()
    )
    AND get_current_user_role() IN ('owner', 'manager')
  );

-- sessions ãƒãƒªã‚·ãƒ¼
CREATE POLICY "session_select_own" ON sessions
  FOR SELECT USING (
    salon_id = get_current_user_salon_id()
    AND (
      stylist_id = get_current_user_staff_id()
      OR get_current_user_role() IN ('owner', 'manager')
    )
  );

CREATE POLICY "session_insert" ON sessions
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND stylist_id = get_current_user_staff_id()
    AND get_current_user_role() IN ('owner', 'manager', 'stylist')
  );

CREATE POLICY "session_update" ON sessions
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND stylist_id = get_current_user_staff_id()
  );

-- transcripts ãƒãƒªã‚·ãƒ¼
CREATE POLICY "transcript_all" ON transcripts
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- speaker_segments ãƒãƒªã‚·ãƒ¼
CREATE POLICY "speaker_segment_all" ON speaker_segments
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- session_analyses ãƒãƒªã‚·ãƒ¼
CREATE POLICY "analysis_all" ON session_analyses
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- session_reports ãƒãƒªã‚·ãƒ¼
CREATE POLICY "report_all" ON session_reports
  FOR ALL USING (
    session_id IN (
      SELECT id FROM sessions 
      WHERE salon_id = get_current_user_salon_id()
        AND (
          stylist_id = get_current_user_staff_id()
          OR get_current_user_role() IN ('owner', 'manager')
        )
    )
  );

-- success_cases ãƒãƒªã‚·ãƒ¼
CREATE POLICY "success_case_select" ON success_cases
  FOR SELECT USING (
    is_public = true
    OR salon_id = get_current_user_salon_id()
  );

CREATE POLICY "success_case_insert" ON success_cases
  FOR INSERT WITH CHECK (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "success_case_update" ON success_cases
  FOR UPDATE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "success_case_delete" ON success_cases
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() = 'owner'
  );

-- roleplay_sessions ãƒãƒªã‚·ãƒ¼
CREATE POLICY "roleplay_select" ON roleplay_sessions
  FOR SELECT USING (
    staff_id = get_current_user_staff_id()
    OR get_current_user_role() IN ('owner', 'manager')
  );

CREATE POLICY "roleplay_insert" ON roleplay_sessions
  FOR INSERT WITH CHECK (
    staff_id = get_current_user_staff_id()
  );

CREATE POLICY "roleplay_update" ON roleplay_sessions
  FOR UPDATE USING (
    staff_id = get_current_user_staff_id()
  );

-- customers ãƒãƒªã‚·ãƒ¼
CREATE POLICY "customer_select" ON customers
  FOR SELECT USING (salon_id = get_current_user_salon_id());

CREATE POLICY "customer_insert" ON customers
  FOR INSERT WITH CHECK (salon_id = get_current_user_salon_id());

CREATE POLICY "customer_update" ON customers
  FOR UPDATE USING (salon_id = get_current_user_salon_id());

CREATE POLICY "customer_delete" ON customers
  FOR DELETE USING (
    salon_id = get_current_user_salon_id()
    AND get_current_user_role() IN ('owner', 'manager')
  );

-- ============================================================
-- é–¢æ•°ãƒ»ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
-- ============================================================

-- ãƒ™ã‚¯ãƒˆãƒ«é¡ä¼¼æ¤œç´¢é–¢æ•°
CREATE OR REPLACE FUNCTION search_success_cases(
  query_embedding VECTOR(1536),
  match_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 5,
  p_salon_id UUID DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  concern_keywords TEXT[],
  successful_talk TEXT,
  key_tactics TEXT[],
  sold_product VARCHAR,
  similarity FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    sc.id,
    sc.concern_keywords,
    sc.successful_talk,
    sc.key_tactics,
    sc.sold_product,
    1 - (sc.embedding <=> query_embedding) AS similarity
  FROM success_cases sc
  WHERE
    sc.embedding IS NOT NULL
    AND (sc.is_public = true OR sc.salon_id = p_salon_id)
    AND 1 - (sc.embedding <=> query_embedding) > match_threshold
  ORDER BY sc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- ã‚¹ã‚¿ãƒƒãƒ•çµ±è¨ˆå–å¾—é–¢æ•°
CREATE OR REPLACE FUNCTION get_staff_statistics(
  p_staff_id UUID,
  p_start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '30 days',
  p_end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
  total_sessions BIGINT,
  avg_score NUMERIC,
  conversion_count BIGINT,
  conversion_rate NUMERIC,
  total_duration_minutes BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(DISTINCT s.id) AS total_sessions,
    COALESCE(ROUND(AVG(sr.overall_score), 1), 0) AS avg_score,
    COALESCE(
      SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END),
      0
    ) AS conversion_count,
    COALESCE(
      ROUND(
        SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END)::NUMERIC / 
        NULLIF(COUNT(DISTINCT s.id), 0) * 100,
        1
      ),
      0
    ) AS conversion_rate,
    COALESCE(
      SUM(EXTRACT(EPOCH FROM (s.ended_at - s.started_at)) / 60)::BIGINT,
      0
    ) AS total_duration_minutes
  FROM sessions s
  LEFT JOIN session_reports sr ON sr.session_id = s.id
  LEFT JOIN session_analyses sa ON sa.session_id = s.id AND sa.indicator_type = 'conversion'
  WHERE
    s.stylist_id = p_staff_id
    AND s.status = 'completed'
    AND s.started_at >= p_start_date
    AND s.started_at <= p_end_date;
END;
$$;

-- åº—èˆ—çµ±è¨ˆå–å¾—é–¢æ•°
CREATE OR REPLACE FUNCTION get_salon_statistics(
  p_salon_id UUID,
  p_start_date TIMESTAMPTZ DEFAULT NOW() - INTERVAL '30 days',
  p_end_date TIMESTAMPTZ DEFAULT NOW()
)
RETURNS TABLE (
  total_sessions BIGINT,
  avg_score NUMERIC,
  conversion_rate NUMERIC,
  active_stylists BIGINT,
  top_performer_id UUID,
  top_performer_name VARCHAR,
  top_performer_score NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  WITH session_stats AS (
    SELECT
      s.stylist_id,
      COUNT(*) AS session_count,
      AVG(sr.overall_score) AS avg_score
    FROM sessions s
    LEFT JOIN session_reports sr ON sr.session_id = s.id
    WHERE
      s.salon_id = p_salon_id
      AND s.status = 'completed'
      AND s.started_at >= p_start_date
      AND s.started_at <= p_end_date
    GROUP BY s.stylist_id
  ),
  top_performer AS (
    SELECT
      st.id,
      st.name,
      ss.avg_score
    FROM session_stats ss
    JOIN staffs st ON st.id = ss.stylist_id
    ORDER BY ss.avg_score DESC NULLS LAST
    LIMIT 1
  )
  SELECT
    (SELECT COUNT(*) FROM sessions WHERE salon_id = p_salon_id AND status = 'completed' AND started_at >= p_start_date AND started_at <= p_end_date) AS total_sessions,
    (SELECT ROUND(AVG(sr.overall_score), 1) FROM sessions s JOIN session_reports sr ON sr.session_id = s.id WHERE s.salon_id = p_salon_id AND s.status = 'completed' AND s.started_at >= p_start_date AND s.started_at <= p_end_date) AS avg_score,
    (SELECT ROUND(
      SUM(CASE WHEN (sa.details->>'converted')::boolean = true THEN 1 ELSE 0 END)::NUMERIC / 
      NULLIF(COUNT(DISTINCT s.id), 0) * 100, 1)
    FROM sessions s
    LEFT JOIN session_analyses sa ON sa.session_id = s.id AND sa.indicator_type = 'conversion'
    WHERE s.salon_id = p_salon_id AND s.status = 'completed' AND s.started_at >= p_start_date AND s.started_at <= p_end_date
    ) AS conversion_rate,
    (SELECT COUNT(DISTINCT stylist_id) FROM sessions WHERE salon_id = p_salon_id AND started_at >= p_start_date AND started_at <= p_end_date) AS active_stylists,
    tp.id AS top_performer_id,
    tp.name AS top_performer_name,
    ROUND(tp.avg_score, 1) AS top_performer_score
  FROM top_performer tp;
END;
$$;

-- ============================================================
-- å£°ç´‹è­˜åˆ¥é–¢æ•°
-- ============================================================

-- å£°ç´‹ã«ã‚ˆã‚‹é¡§å®¢ãƒãƒƒãƒãƒ³ã‚°é–¢æ•°
CREATE OR REPLACE FUNCTION match_customer_by_voice(
  query_embedding VECTOR(512),
  salon_id_param UUID,
  match_threshold FLOAT DEFAULT 0.65,
  match_count INT DEFAULT 5
)
RETURNS TABLE (
  id UUID,
  name VARCHAR,
  similarity FLOAT,
  total_visits INTEGER,
  last_visit_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    c.id,
    c.name,
    1 - (c.voice_embedding <=> query_embedding) AS similarity,
    c.total_visits,
    c.last_visit_at
  FROM customers c
  WHERE
    c.salon_id = salon_id_param
    AND c.voice_embedding IS NOT NULL
    AND 1 - (c.voice_embedding <=> query_embedding) > match_threshold
  ORDER BY c.voice_embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- é¡§å®¢ã®å£°ç´‹åŸ‹ã‚è¾¼ã¿æ›´æ–°é–¢æ•°ï¼ˆåŠ é‡å¹³å‡ï¼‰
CREATE OR REPLACE FUNCTION update_customer_embedding(
  customer_id_param UUID,
  new_embedding VECTOR(512)
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  current_visits INTEGER;
  current_embedding VECTOR(512);
  weight FLOAT;
BEGIN
  -- ç¾åœ¨ã®è¨ªå•å›æ•°ã¨åŸ‹ã‚è¾¼ã¿ã‚’å–å¾—
  SELECT total_visits, voice_embedding
  INTO current_visits, current_embedding
  FROM customers
  WHERE id = customer_id_param;

  IF current_embedding IS NULL THEN
    -- åˆå›ã®å ´åˆã¯ãã®ã¾ã¾è¨­å®š
    UPDATE customers
    SET
      voice_embedding = new_embedding,
      embedding_updated_at = NOW(),
      total_visits = current_visits + 1,
      last_visit_at = NOW(),
      updated_at = NOW()
    WHERE id = customer_id_param;
  ELSE
    -- åŠ é‡å¹³å‡ã§æ›´æ–°ï¼ˆæ–°ã—ã„åŸ‹ã‚è¾¼ã¿ã®é‡ã¿ã‚’è¨ˆç®—ï¼‰
    -- é‡ã¿ = 1 / (total_visits + 1)ã€æœ€å¤§0.3
    weight := LEAST(1.0 / (current_visits + 1), 0.3);

    UPDATE customers
    SET
      voice_embedding = (
        (1 - weight) * current_embedding::vector + weight * new_embedding::vector
      )::VECTOR(512),
      embedding_updated_at = NOW(),
      total_visits = current_visits + 1,
      last_visit_at = NOW(),
      updated_at = NOW()
    WHERE id = customer_id_param;
  END IF;
END;
$$;

-- é¡§å®¢ä½œæˆé–¢æ•°ï¼ˆå£°ç´‹ä»˜ãï¼‰
CREATE OR REPLACE FUNCTION create_customer_with_embedding(
  salon_id_param UUID,
  name_param VARCHAR DEFAULT NULL,
  embedding_param VECTOR(512) DEFAULT NULL,
  metadata_param JSONB DEFAULT '{}'::jsonb
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_customer_id UUID;
BEGIN
  INSERT INTO customers (
    salon_id,
    name,
    voice_embedding,
    embedding_updated_at,
    metadata
  ) VALUES (
    salon_id_param,
    name_param,
    embedding_param,
    CASE WHEN embedding_param IS NOT NULL THEN NOW() ELSE NULL END,
    metadata_param
  )
  RETURNING id INTO new_customer_id;

  RETURN new_customer_id;
END;
$$;

-- ============================================================
-- ğŸ†• ã‚¹ã‚¿ãƒƒãƒ•å£°ç´‹è­˜åˆ¥é–¢æ•°ï¼ˆ2025-12-09è¿½åŠ ï¼‰
-- ============================================================

-- ã‚¹ã‚¿ãƒƒãƒ•å£°ç´‹ãƒãƒƒãƒãƒ³ã‚°é–¢æ•°
-- ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¸­ã®è©±è€…åˆ†é›¢å¾Œã€ã‚¹ã‚¿ãƒƒãƒ•ã‚’è‡ªå‹•è­˜åˆ¥
CREATE OR REPLACE FUNCTION match_staff_by_voice(
  query_embedding VECTOR(512),
  salon_id_param UUID,
  match_threshold FLOAT DEFAULT 0.65,
  match_count INT DEFAULT 3
)
RETURNS TABLE (
  staff_id UUID,
  name VARCHAR,
  similarity FLOAT,
  confidence_level TEXT  -- 'high' (0.85+), 'medium' (0.75-0.85), 'low' (0.65-0.75)
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    s.id AS staff_id,
    s.name,
    1 - (s.voice_embedding <=> query_embedding) AS similarity,
    CASE
      WHEN 1 - (s.voice_embedding <=> query_embedding) >= 0.85 THEN 'high'
      WHEN 1 - (s.voice_embedding <=> query_embedding) >= 0.75 THEN 'medium'
      ELSE 'low'
    END AS confidence_level
  FROM staffs s
  WHERE
    s.salon_id = salon_id_param
    AND s.is_active = true
    AND s.voice_embedding IS NOT NULL
    AND 1 - (s.voice_embedding <=> query_embedding) > match_threshold
  ORDER BY s.voice_embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- ã‚¹ã‚¿ãƒƒãƒ•å£°ç´‹ç™»éŒ²ãƒ»æ›´æ–°é–¢æ•°
-- ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ™‚ã¾ãŸã¯è¿½åŠ ç™»éŒ²æ™‚ã«ä½¿ç”¨
CREATE OR REPLACE FUNCTION register_staff_voice(
  staff_id_param UUID,
  embedding_param VECTOR(512),
  is_additional BOOLEAN DEFAULT false
)
RETURNS TABLE (
  success BOOLEAN,
  sample_count INTEGER,
  message TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  current_embedding VECTOR(512);
  current_sample_count INTEGER;
  weight FLOAT;
BEGIN
  -- ç¾åœ¨ã®å£°ç´‹æƒ…å ±ã‚’å–å¾—
  SELECT voice_embedding, voice_sample_count
  INTO current_embedding, current_sample_count
  FROM staffs
  WHERE id = staff_id_param;

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, 0, 'ã‚¹ã‚¿ãƒƒãƒ•ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'::TEXT;
    RETURN;
  END IF;

  IF current_embedding IS NULL OR NOT is_additional THEN
    -- åˆå›ç™»éŒ²ã¾ãŸã¯ä¸Šæ›¸ãç™»éŒ²
    UPDATE staffs
    SET
      voice_embedding = embedding_param,
      voice_registered_at = NOW(),
      voice_sample_count = 1,
      updated_at = NOW()
    WHERE id = staff_id_param;

    RETURN QUERY SELECT true, 1, 'å£°ç´‹ã‚’ç™»éŒ²ã—ã¾ã—ãŸ'::TEXT;
  ELSE
    -- è¿½åŠ ã‚µãƒ³ãƒ—ãƒ«ã§åŠ é‡å¹³å‡æ›´æ–°
    -- ã‚µãƒ³ãƒ—ãƒ«æ•°ãŒå¢—ãˆã‚‹ã»ã©æ–°ã—ã„ã‚µãƒ³ãƒ—ãƒ«ã®é‡ã¿ã¯å°ã•ããªã‚‹ï¼ˆæœ€å¤§0.2ï¼‰
    weight := LEAST(1.0 / (current_sample_count + 1), 0.2);

    UPDATE staffs
    SET
      voice_embedding = (
        (1 - weight) * current_embedding::vector + weight * embedding_param::vector
      )::VECTOR(512),
      voice_sample_count = current_sample_count + 1,
      updated_at = NOW()
    WHERE id = staff_id_param;

    RETURN QUERY SELECT true, current_sample_count + 1,
      format('å£°ç´‹ã‚’æ›´æ–°ã—ã¾ã—ãŸï¼ˆã‚µãƒ³ãƒ—ãƒ«æ•°: %sï¼‰', current_sample_count + 1)::TEXT;
  END IF;
END;
$$;

-- ============================================================
-- ğŸ†• ãƒ‡ãƒã‚¤ã‚¹ç®¡ç†é–¢æ•°ï¼ˆ2025-12-09è¿½åŠ ï¼‰
-- ============================================================

-- ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ç”Ÿæˆé–¢æ•°
CREATE OR REPLACE FUNCTION generate_activation_code(
  device_id_param UUID,
  created_by_param UUID,
  validity_hours INTEGER DEFAULT 24
)
RETURNS TABLE (
  activation_code VARCHAR(6),
  expires_at TIMESTAMPTZ
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_code VARCHAR(6);
  new_expires_at TIMESTAMPTZ;
  max_attempts INTEGER := 10;
  attempt INTEGER := 0;
BEGIN
  new_expires_at := NOW() + (validity_hours || ' hours')::INTERVAL;

  -- ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã‚‹ã¾ã§ãƒªãƒˆãƒ©ã‚¤
  LOOP
    attempt := attempt + 1;
    -- 6æ¡ã®æ•°å­—ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
    new_code := LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');

    -- æœªä½¿ç”¨ã‹ã¤æœ‰åŠ¹æœŸé™å†…ã®é‡è¤‡ã‚³ãƒ¼ãƒ‰ãŒãªã„ã‹ç¢ºèª
    IF NOT EXISTS (
      SELECT 1 FROM device_activations
      WHERE device_activations.activation_code = new_code
        AND used_at IS NULL
        AND device_activations.expires_at > NOW()
    ) THEN
      EXIT;
    END IF;

    IF attempt >= max_attempts THEN
      RAISE EXCEPTION 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ';
    END IF;
  END LOOP;

  -- æ—¢å­˜ã®æœªä½¿ç”¨ã‚³ãƒ¼ãƒ‰ã‚’ç„¡åŠ¹åŒ–
  UPDATE device_activations
  SET expires_at = NOW()
  WHERE device_activations.device_id = device_id_param
    AND used_at IS NULL
    AND device_activations.expires_at > NOW();

  -- æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã‚’æŒ¿å…¥
  INSERT INTO device_activations (device_id, activation_code, expires_at, created_by)
  VALUES (device_id_param, new_code, new_expires_at, created_by_param);

  RETURN QUERY SELECT new_code, new_expires_at;
END;
$$;

-- ãƒ‡ãƒã‚¤ã‚¹ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
CREATE OR REPLACE FUNCTION activate_device(
  activation_code_param VARCHAR(6),
  device_identifier_param VARCHAR(255),
  metadata_param JSONB DEFAULT '{}'::jsonb
)
RETURNS TABLE (
  success BOOLEAN,
  device_id UUID,
  salon_id UUID,
  device_name VARCHAR,
  message TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  activation_record RECORD;
  device_record RECORD;
BEGIN
  -- ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’æ¤œè¨¼
  SELECT da.*, d.salon_id, d.device_name
  INTO activation_record
  FROM device_activations da
  JOIN devices d ON d.id = da.device_id
  WHERE da.activation_code = activation_code_param
    AND da.used_at IS NULL
    AND da.expires_at > NOW();

  IF NOT FOUND THEN
    RETURN QUERY SELECT false, NULL::UUID, NULL::UUID, NULL::VARCHAR,
      'ç„¡åŠ¹ã¾ãŸã¯æœŸé™åˆ‡ã‚Œã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã§ã™'::TEXT;
    RETURN;
  END IF;

  -- ãƒ‡ãƒã‚¤ã‚¹ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ãƒˆ
  UPDATE devices
  SET
    status = 'active',
    device_identifier = device_identifier_param,
    activated_at = NOW(),
    last_active_at = NOW(),
    metadata = metadata_param,
    updated_at = NOW()
  WHERE id = activation_record.device_id;

  -- ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ç”¨æ¸ˆã¿ã«
  UPDATE device_activations
  SET used_at = NOW()
  WHERE id = activation_record.id;

  RETURN QUERY SELECT
    true,
    activation_record.device_id,
    activation_record.salon_id,
    activation_record.device_name,
    'ãƒ‡ãƒã‚¤ã‚¹ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ãƒˆã•ã‚Œã¾ã—ãŸ'::TEXT;
END;
$$;

-- ãƒ‡ãƒã‚¤ã‚¹èªè¨¼é–¢æ•°ï¼ˆã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ã«ä½¿ç”¨ï¼‰
CREATE OR REPLACE FUNCTION authenticate_device(
  device_identifier_param VARCHAR(255)
)
RETURNS TABLE (
  is_valid BOOLEAN,
  device_id UUID,
  salon_id UUID,
  device_name VARCHAR,
  seat_number INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  RETURN QUERY
  SELECT
    true AS is_valid,
    d.id AS device_id,
    d.salon_id,
    d.device_name,
    d.seat_number
  FROM devices d
  WHERE d.device_identifier = device_identifier_param
    AND d.status = 'active';

  -- ãƒ‡ãƒã‚¤ã‚¹ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã€æœ€çµ‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ—¥æ™‚ã‚’æ›´æ–°
  IF FOUND THEN
    UPDATE devices
    SET last_active_at = NOW()
    WHERE device_identifier = device_identifier_param;
  END IF;
END;
$$;
```

### 7.2 ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­è¨ˆ

#### 7.2.1 ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä¸€è¦§

| ãƒ†ãƒ¼ãƒ–ãƒ« | ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å | ã‚«ãƒ©ãƒ  | ç¨®åˆ¥ | ç”¨é€” |
|---------|--------------|--------|------|------|
| salons | idx_salons_plan | plan | B-tree | ãƒ—ãƒ©ãƒ³åˆ¥æ¤œç´¢ |
| staffs | idx_staffs_salon_id | salon_id | B-tree | åº—èˆ—åˆ¥ã‚¹ã‚¿ãƒƒãƒ•å–å¾— |
| staffs | idx_staffs_role | role | B-tree | ãƒ­ãƒ¼ãƒ«åˆ¥æ¤œç´¢ |
| staffs | idx_staffs_salon_active | salon_id, is_active | B-tree (éƒ¨åˆ†) | ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¹ã‚¿ãƒƒãƒ•å–å¾— |
| staffs | idx_staffs_voice_embedding | voice_embedding | HNSW | ğŸ†• ã‚¹ã‚¿ãƒƒãƒ•å£°ç´‹æ¤œç´¢ |
| devices | idx_devices_salon_id | salon_id | B-tree | ğŸ†• åº—èˆ—åˆ¥ãƒ‡ãƒã‚¤ã‚¹å–å¾— |
| devices | idx_devices_status | status | B-tree | ğŸ†• ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¥æ¤œç´¢ |
| devices | idx_devices_salon_active | salon_id, status | B-tree (éƒ¨åˆ†) | ğŸ†• ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ‡ãƒã‚¤ã‚¹å–å¾— |
| devices | idx_devices_last_active | last_active_at DESC | B-tree | ğŸ†• æœ€çµ‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é †å–å¾— |
| devices | devices_identifier_unique | device_identifier | UNIQUE | ğŸ†• ãƒ‡ãƒã‚¤ã‚¹è­˜åˆ¥å­ä¸€æ„ |
| device_activations | idx_device_activations_code_unique | activation_code | B-tree (éƒ¨åˆ†) | ğŸ†• æœªä½¿ç”¨ã‚³ãƒ¼ãƒ‰ä¸€æ„åˆ¶ç´„ |
| device_activations | idx_device_activations_expires | expires_at | B-tree (éƒ¨åˆ†) | ğŸ†• æœ‰åŠ¹æœŸé™æ¤œç´¢ |
| device_seat_history | idx_device_seat_history_device_id | device_id | B-tree | ğŸ†• ãƒ‡ãƒã‚¤ã‚¹åˆ¥å±¥æ­´å–å¾— |
| device_seat_history | idx_device_seat_history_changed_at | changed_at DESC | B-tree | ğŸ†• å¤‰æ›´æ—¥æ™‚é †å–å¾— |
| sessions | idx_sessions_salon_started | salon_id, started_at | B-tree | åº—èˆ—åˆ¥ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ |
| sessions | idx_sessions_stylist_started | stylist_id, started_at | B-tree | ã‚¹ã‚¿ã‚¤ãƒªã‚¹ãƒˆåˆ¥å±¥æ­´ |
| sessions | idx_sessions_device_id | device_id | B-tree | ğŸ†• ãƒ‡ãƒã‚¤ã‚¹åˆ¥ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾— |
| sessions | idx_sessions_active | device_id, status | B-tree (éƒ¨åˆ†) | ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚»ãƒƒã‚·ãƒ§ãƒ³æ¤œç´¢ |
| transcripts | idx_transcripts_session_chunk | session_id, chunk_index | B-tree | ãƒãƒ£ãƒ³ã‚¯é †å–å¾— |
| speaker_segments | idx_speaker_segments_session_time | session_id, start_time_ms | B-tree | æ™‚ç³»åˆ—å–å¾— |
| session_analyses | idx_session_analyses_session_indicator | session_id, indicator_type | B-tree | æŒ‡æ¨™åˆ¥åˆ†æå–å¾— |
| session_reports | idx_session_reports_score | overall_score | B-tree (DESC) | ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚° |
| success_cases | idx_success_cases_concern | concern_keywords | GIN | ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢ |
| success_cases | idx_success_cases_embedding | embedding | HNSW | ãƒ™ã‚¯ãƒˆãƒ«é¡ä¼¼æ¤œç´¢ |
| customers | idx_customers_salon_id | salon_id | B-tree | åº—èˆ—åˆ¥é¡§å®¢å–å¾— |
| customers | idx_customers_name | name | B-tree (éƒ¨åˆ†) | åå‰æ¤œç´¢ï¼ˆNULLé™¤å¤–ï¼‰ |
| customers | idx_customers_last_visit | salon_id, last_visit_at | B-tree | æœ€çµ‚è¨ªå•é †å–å¾— |
| customers | idx_customers_voice_embedding | voice_embedding | HNSW | å£°ç´‹é¡ä¼¼æ¤œç´¢ |
| sessions | idx_sessions_customer_id | customer_id | B-tree | é¡§å®¢åˆ¥ã‚»ãƒƒã‚·ãƒ§ãƒ³å–å¾— |

#### 7.2.2 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°è¨­å®š

```sql
-- PostgreSQLè¨­å®šæ¨å¥¨å€¤ï¼ˆSupabase Proä»¥ä¸Šï¼‰

-- shared_buffers: ãƒ¡ãƒ¢ãƒªã®25%ç¨‹åº¦
-- effective_cache_size: ãƒ¡ãƒ¢ãƒªã®75%ç¨‹åº¦
-- work_mem: 64MBï¼ˆè¤‡é›‘ãªã‚½ãƒ¼ãƒˆãƒ»é›†è¨ˆç”¨ï¼‰
-- maintenance_work_mem: 512MBï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆç”¨ï¼‰

-- HNSWã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æ¤œç´¢ç²¾åº¦è¨­å®š
SET hnsw.ef_search = 100;  -- æ¤œç´¢æ™‚ã®æ¢ç´¢ç¯„å›²ï¼ˆå¤§ãã„ã»ã©ç²¾åº¦â†‘ã€é€Ÿåº¦â†“ï¼‰

-- çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
ANALYZE salons;
ANALYZE staffs;
ANALYZE sessions;
ANALYZE transcripts;
ANALYZE speaker_segments;
ANALYZE session_analyses;
ANALYZE session_reports;
ANALYZE success_cases;
ANALYZE customers;
```

---
