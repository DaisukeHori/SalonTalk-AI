## 9. 外部連携詳細設計

### 9.1 Anthropic Claude API 連携

#### 9.1.1 クライアント実装

```typescript
// src/lib/claude/client.ts

import Anthropic from '@anthropic-ai/sdk';

interface ClaudeClientConfig {
  apiKey: string;
  maxRetries?: number;
  timeout?: number;
}

export class ClaudeClient {
  private client: Anthropic;
  private maxRetries: number;
  private timeout: number;

  constructor(config: ClaudeClientConfig) {
    this.client = new Anthropic({
      apiKey: config.apiKey,
    });
    this.maxRetries = config.maxRetries ?? 3;
    this.timeout = config.timeout ?? 60000;
  }

  /**
   * メッセージ送信
   */
  async sendMessage(params: {
    system?: string;
    messages: Array<{ role: 'user' | 'assistant'; content: string }>;
    maxTokens?: number;
    temperature?: number;
  }): Promise<ClaudeResponse> {
    let lastError: Error | null = null;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        const response = await this.client.messages.create({
          model: 'claude-sonnet-4-5-20250929',
          max_tokens: params.maxTokens ?? 4096,
          system: params.system,
          messages: params.messages,
          temperature: params.temperature ?? 1,
        });

        return {
          content: response.content[0].type === 'text' 
            ? response.content[0].text 
            : '',
          usage: {
            inputTokens: response.usage.input_tokens,
            outputTokens: response.usage.output_tokens,
          },
          stopReason: response.stop_reason,
        };
      } catch (error: any) {
        lastError = error;
        
        // リトライ可能なエラーかチェック
        if (this.shouldRetry(error, attempt)) {
          const delay = this.calculateBackoff(attempt, error);
          console.log(`Claude API retry attempt ${attempt}/${this.maxRetries}, waiting ${delay}ms`);
          await this.sleep(delay);
          continue;
        }
        
        throw this.wrapError(error);
      }
    }
    
    throw this.wrapError(lastError!);
  }

  /**
   * JSON形式で応答を要求
   */
  async sendMessageForJson<T>(params: {
    system?: string;
    messages: Array<{ role: 'user' | 'assistant'; content: string }>;
    maxTokens?: number;
  }): Promise<T> {
    const response = await this.sendMessage({
      ...params,
      temperature: 0,  // JSONの場合は温度を0に
    });

    // JSON抽出
    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new ClaudeError('PARSE_ERROR', 'JSONレスポンスの解析に失敗しました');
    }

    try {
      return JSON.parse(jsonMatch[0]) as T;
    } catch {
      throw new ClaudeError('PARSE_ERROR', 'JSONレスポンスの解析に失敗しました');
    }
  }

  /**
   * リトライ判定
   */
  private shouldRetry(error: any, attempt: number): boolean {
    if (attempt >= this.maxRetries) return false;
    
    // レート制限エラー
    if (error.status === 429) return true;
    
    // サーバーエラー
    if (error.status >= 500) return true;
    
    // ネットワークエラー
    if (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT') return true;
    
    return false;
  }

  /**
   * バックオフ時間計算
   */
  private calculateBackoff(attempt: number, error: any): number {
    // レート制限の場合はRetry-Afterヘッダーを使用
    if (error.status === 429 && error.headers?.['retry-after']) {
      return parseInt(error.headers['retry-after'], 10) * 1000;
    }
    
    // 指数バックオフ + ジッター
    const baseDelay = error.status === 429 ? 5000 : 1000;
    const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);
    const jitter = Math.random() * 1000;
    
    return Math.min(exponentialDelay + jitter, 60000);  // 最大60秒
  }

  /**
   * エラーラップ
   */
  private wrapError(error: any): ClaudeError {
    if (error instanceof ClaudeError) return error;
    
    const status = error.status || 500;
    const message = error.message || 'Claude API エラー';
    
    if (status === 401) {
      return new ClaudeError('AUTH_ERROR', 'APIキーが無効です', error);
    }
    if (status === 429) {
      return new ClaudeError('RATE_LIMIT', 'レート制限に達しました', error);
    }
    if (status >= 500) {
      return new ClaudeError('SERVER_ERROR', 'Claudeサーバーエラー', error);
    }
    
    return new ClaudeError('UNKNOWN', message, error);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

interface ClaudeResponse {
  content: string;
  usage: {
    inputTokens: number;
    outputTokens: number;
  };
  stopReason: string | null;
}

export class ClaudeError extends Error {
  constructor(
    public readonly code: string,
    message: string,
    public readonly cause?: Error
  ) {
    super(message);
    this.name = 'ClaudeError';
  }
}
```

#### 9.1.2 プロンプトテンプレート

```typescript
// src/lib/claude/prompts.ts

/**
 * 感情分析プロンプト
 */
export const EMOTION_ANALYSIS_PROMPT = `あなたは美容室でのお客様の発話を分析する専門家です。
以下のお客様の発話から感情を分析してください。

## 発話内容
{customerUtterances}

## 分析観点
1. ポジティブな感情（喜び、満足、期待、興味）
2. ネガティブな感情（不満、困惑、不安、悩み）
3. ニュートラルな発話

## 出力形式（JSON）
{
  "positiveRatio": 0-100の数値（ポジティブ発話の割合%）,
  "keywords": ["検出された感情キーワードの配列"],
  "overall": "positive" | "neutral" | "negative"
}

JSONのみを出力してください。説明は不要です。`;

/**
 * 提案品質分析プロンプト
 */
export const PROPOSAL_QUALITY_PROMPT = `あなたは美容室での店販提案を分析する専門家です。
以下のスタイリストの発話から、商品提案の品質を分析してください。

## スタイリストの発話
{stylistUtterances}

## 分析観点
1. 商品提案があるか
2. ベネフィット（お客様にとっての効果・メリット）を伝えているか
3. スペック（成分・機能）だけでなく、感情的価値を伝えているか

## 良い提案の例
- 「これを使うと朝のスタイリングが5分短くなりますよ」（時短=ベネフィット）
- 「サラサラになって、触るのが楽しくなりますよ」（感情的価値）

## 悪い提案の例
- 「オーガニック成分配合です」（スペックのみ）
- 「3000円です」（価格のみ）

## 出力形式（JSON）
{
  "hasProposal": true | false,
  "benefitRatio": 0-100の数値（ベネフィット訴求の割合%）,
  "examples": ["提案内容の具体例"]
}

JSONのみを出力してください。`;

/**
 * 成約判定プロンプト
 */
export const CONVERSION_DETECTION_PROMPT = `あなたは美容室での会話から商品購入を検出する専門家です。
以下の会話から、商品の購入（成約）があったかを判定してください。

## 会話
{conversation}

## 判定基準
- お客様が「買います」「ください」「お願いします」などの購入意思を示した
- スタイリストが「ありがとうございます」と購入確認をした
- 会計や包装の話が出た

## 出力形式（JSON）
{
  "converted": true | false,
  "productName": "購入された商品名" | null,
  "confidence": 0-100の確信度
}

JSONのみを出力してください。`;

/**
 * レポート生成プロンプト
 */
export const REPORT_GENERATION_PROMPT = `あなたは美容室のセッション分析レポートを作成する専門家です。
以下の分析結果に基づいて、スタイリスト向けのフィードバックレポートを作成してください。

## 会話要約
{transcriptSummary}

## 分析結果
- 総合スコア: {overallScore}点
- トーク比率: {talkRatioScore}点（スタイリスト{talkRatioValue}%）
- 質問分析: {questionScore}点（{questionCount}回）
- 感情分析: {emotionScore}点（ポジティブ{emotionValue}%）
- 悩み検出: {concernDetected}
- 提案品質: {proposalScore}点
- 成約: {converted}

## 出力形式（JSON）
{
  "goodPoints": ["良かった点を2-3個、具体的に"],
  "improvementPoints": ["改善ポイントを2-3個、具体的に"],
  "actionItems": ["次回への具体的なアクションを3個"],
  "transcriptSummary": "会話の要約（100文字程度）",
  "aiFeedback": "総合的なフィードバック（200文字程度、励ましを含めて）"
}

JSONのみを出力してください。スタイリストを励ます温かいトーンで書いてください。`;

/**
 * ロールプレイお客様役プロンプト
 */
export const ROLEPLAY_CUSTOMER_PROMPT = `あなたは美容室のお客様役としてロールプレイに参加します。

## シナリオ
{scenario}

## キャラクター設定
{characterSettings}

## ルール
1. 設定されたお客様として自然に応答してください
2. スタイリストの質問や提案に対して、リアルな反応をしてください
3. 設定された悩みや性格に一貫性を持ってください
4. 長すぎる応答は避け、自然な会話のペースを維持してください

## これまでの会話
{conversationHistory}

## スタイリストの発話
{stylistMessage}

お客様として1-2文で応答してください。応答のみを出力し、説明は不要です。`;

/**
 * プロンプト変数置換
 */
export function formatPrompt(template: string, variables: Record<string, string>): string {
  return template.replace(/\{(\w+)\}/g, (match, key) => {
    return variables[key] ?? match;
  });
}
```

### 9.2 OpenAI Embedding API 連携

```typescript
// src/lib/openai/embedding.ts

interface EmbeddingClientConfig {
  apiKey: string;
  model?: string;
}

export class EmbeddingClient {
  private apiKey: string;
  private model: string;
  private baseUrl = 'https://api.openai.com/v1';

  constructor(config: EmbeddingClientConfig) {
    this.apiKey = config.apiKey;
    this.model = config.model ?? 'text-embedding-3-small';
  }

  /**
   * 単一テキストのEmbedding生成
   */
  async createEmbedding(text: string): Promise<number[]> {
    const response = await fetch(`${this.baseUrl}/embeddings`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: this.model,
        input: text,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new EmbeddingError(
        response.status,
        error.error?.message || 'Embedding生成に失敗しました'
      );
    }

    const result = await response.json();
    return result.data[0].embedding;
  }

  /**
   * バッチEmbedding生成（最大20件）
   */
  async createEmbeddings(texts: string[]): Promise<number[][]> {
    if (texts.length === 0) return [];
    if (texts.length > 20) {
      throw new EmbeddingError(400, 'バッチサイズは20件以内にしてください');
    }

    const response = await fetch(`${this.baseUrl}/embeddings`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: this.model,
        input: texts,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new EmbeddingError(
        response.status,
        error.error?.message || 'Embedding生成に失敗しました'
      );
    }

    const result = await response.json();
    return result.data
      .sort((a: any, b: any) => a.index - b.index)
      .map((item: any) => item.embedding);
  }
}

export class EmbeddingError extends Error {
  constructor(
    public readonly status: number,
    message: string
  ) {
    super(message);
    this.name = 'EmbeddingError';
  }
}
```

### 9.3 pyannote Server 連携

```typescript
// src/lib/pyannote/client.ts

interface PyannoteClientConfig {
  serverUrl: string;
  apiKey: string;
  timeout?: number;
}

interface DiarizeParams {
  sessionId: string;
  audioFile: Blob;
  callbackUrl: string;
  numSpeakers?: number;
  chunkIndex?: number;
}

interface DiarizeResponse {
  status: 'processing';
  sessionId: string;
  estimatedTime: number;
}

interface DiarizationResult {
  sessionId: string;
  status: 'completed' | 'failed';
  segments?: Array<{
    speaker: string;
    start: number;
    end: number;
    confidence?: number;
  }>;
  error?: string;
}

export class PyannoteClient {
  private serverUrl: string;
  private apiKey: string;
  private timeout: number;

  constructor(config: PyannoteClientConfig) {
    this.serverUrl = config.serverUrl.replace(/\/$/, '');
    this.apiKey = config.apiKey;
    this.timeout = config.timeout ?? 300000;  // 5分
  }

  /**
   * 話者分離リクエスト送信
   */
  async diarize(params: DiarizeParams): Promise<DiarizeResponse> {
    const formData = new FormData();
    formData.append('audio', params.audioFile, 'audio.wav');
    formData.append('callback_url', params.callbackUrl);
    formData.append('num_speakers', String(params.numSpeakers ?? 2));
    if (params.chunkIndex !== undefined) {
      formData.append('chunk_index', String(params.chunkIndex));
    }

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(
        `${this.serverUrl}/diarize/${params.sessionId}`,
        {
          method: 'POST',
          headers: {
            'X-API-Key': this.apiKey,
          },
          body: formData,
          signal: controller.signal,
        }
      );

      clearTimeout(timeoutId);

      if (!response.ok) {
        const error = await response.text();
        throw new PyannoteError(response.status, error);
      }

      const result = await response.json();
      return {
        status: 'processing',
        sessionId: result.session_id,
        estimatedTime: result.estimated_time,
      };
    } catch (error: any) {
      clearTimeout(timeoutId);
      
      if (error.name === 'AbortError') {
        throw new PyannoteError(408, 'リクエストがタイムアウトしました');
      }
      
      throw error instanceof PyannoteError 
        ? error 
        : new PyannoteError(500, error.message);
    }
  }

  /**
   * 処理状態確認
   */
  async getStatus(sessionId: string): Promise<{
    status: 'pending' | 'processing' | 'completed' | 'failed';
    progress?: number;
  }> {
    const response = await fetch(
      `${this.serverUrl}/status/${sessionId}`,
      {
        headers: {
          'X-API-Key': this.apiKey,
        },
      }
    );

    if (!response.ok) {
      throw new PyannoteError(response.status, 'ステータス取得に失敗しました');
    }

    return response.json();
  }

  /**
   * ヘルスチェック
   */
  async healthCheck(): Promise<boolean> {
    try {
      const response = await fetch(`${this.serverUrl}/health`, {
        timeout: 5000,
      } as any);
      return response.ok;
    } catch {
      return false;
    }
  }
}

export class PyannoteError extends Error {
  constructor(
    public readonly status: number,
    message: string
  ) {
    super(message);
    this.name = 'PyannoteError';
  }
}

/**
 * 話者ラベルをアプリケーション用に変換
 */
export function mapSpeakerLabel(
  pyannoteLabel: string,
  firstSpeaker: string
): 'stylist' | 'customer' | 'unknown' {
  // 最初に発話した人をスタイリストと仮定
  if (pyannoteLabel === firstSpeaker) {
    return 'stylist';
  }
  if (pyannoteLabel.startsWith('SPEAKER_')) {
    return 'customer';
  }
  return 'unknown';
}
```

---
