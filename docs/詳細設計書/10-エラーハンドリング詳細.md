## 10. エラーハンドリング詳細

### 10.1 エラーコード体系

```typescript
// src/errors/errorCodes.ts

/**
 * エラーコード定義
 */
export const ErrorCodes = {
  // 認証エラー (AUTH_xxx)
  AUTH_001: { code: 'AUTH_001', message: '認証トークンが無効です', httpStatus: 401 },
  AUTH_002: { code: 'AUTH_002', message: 'トークンの有効期限が切れています', httpStatus: 401 },
  AUTH_003: { code: 'AUTH_003', message: 'この操作を行う権限がありません', httpStatus: 403 },
  AUTH_004: { code: 'AUTH_004', message: 'アカウントが無効です', httpStatus: 403 },

  // バリデーションエラー (VAL_xxx)
  VAL_001: { code: 'VAL_001', message: '必須項目が入力されていません', httpStatus: 400 },
  VAL_002: { code: 'VAL_002', message: '入力形式が正しくありません', httpStatus: 400 },
  VAL_003: { code: 'VAL_003', message: '入力値が範囲外です', httpStatus: 400 },
  VAL_004: { code: 'VAL_004', message: 'ファイルサイズが上限を超えています', httpStatus: 400 },
  VAL_005: { code: 'VAL_005', message: 'ファイル形式がサポートされていません', httpStatus: 400 },

  // セッションエラー (SES_xxx)
  SES_001: { code: 'SES_001', message: 'セッションが見つかりません', httpStatus: 404 },
  SES_002: { code: 'SES_002', message: 'セッションは既に終了しています', httpStatus: 400 },
  SES_003: { code: 'SES_003', message: 'セッションは処理中です', httpStatus: 409 },
  SES_004: { code: 'SES_004', message: '既にアクティブなセッションがあります', httpStatus: 409 },

  // AI処理エラー (AI_xxx)
  AI_001: { code: 'AI_001', message: 'AI分析処理に失敗しました', httpStatus: 500 },
  AI_002: { code: 'AI_002', message: 'AI APIのレート制限に達しました', httpStatus: 429 },
  AI_003: { code: 'AI_003', message: 'AI処理がタイムアウトしました', httpStatus: 504 },

  // 話者分離エラー (DIA_xxx)
  DIA_001: { code: 'DIA_001', message: '話者分離処理に失敗しました', httpStatus: 500 },
  DIA_002: { code: 'DIA_002', message: '話者分離がタイムアウトしました', httpStatus: 504 },
  DIA_003: { code: 'DIA_003', message: '話者分離サーバーに接続できません', httpStatus: 503 },

  // データベースエラー (DB_xxx)
  DB_001: { code: 'DB_001', message: 'データベースに接続できません', httpStatus: 500 },
  DB_002: { code: 'DB_002', message: 'データの取得に失敗しました', httpStatus: 500 },
  DB_003: { code: 'DB_003', message: 'データの保存に失敗しました', httpStatus: 500 },
  DB_004: { code: 'DB_004', message: 'データが既に存在します', httpStatus: 409 },

  // ネットワークエラー (NET_xxx)
  NET_001: { code: 'NET_001', message: 'ネットワークに接続できません', httpStatus: 503 },
  NET_002: { code: 'NET_002', message: '通信がタイムアウトしました', httpStatus: 504 },

  // ストレージエラー (STR_xxx)
  STR_001: { code: 'STR_001', message: 'ファイルのアップロードに失敗しました', httpStatus: 500 },
  STR_002: { code: 'STR_002', message: 'ファイルのダウンロードに失敗しました', httpStatus: 500 },

  // システムエラー (SYS_xxx)
  SYS_001: { code: 'SYS_001', message: 'システムエラーが発生しました', httpStatus: 500 },
} as const;

export type ErrorCode = keyof typeof ErrorCodes;
```

### 10.2 エラーハンドリングクラス

```typescript
// src/errors/AppError.ts

import { ErrorCodes, ErrorCode } from './errorCodes';

/**
 * アプリケーションエラー基底クラス
 */
export class AppError extends Error {
  public readonly code: string;
  public readonly httpStatus: number;
  public readonly details?: Record<string, unknown>;
  public readonly cause?: Error;

  constructor(
    errorCode: ErrorCode,
    details?: Record<string, unknown>,
    cause?: Error
  ) {
    const errorDef = ErrorCodes[errorCode];
    super(errorDef.message);
    
    this.name = 'AppError';
    this.code = errorDef.code;
    this.httpStatus = errorDef.httpStatus;
    this.details = details;
    this.cause = cause;
    
    // スタックトレースを保持
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * JSONシリアライズ用
   */
  toJSON() {
    return {
      error: {
        code: this.code,
        message: this.message,
        details: this.details,
      },
    };
  }

  /**
   * ログ出力用
   */
  toLogObject() {
    return {
      errorCode: this.code,
      message: this.message,
      httpStatus: this.httpStatus,
      details: this.details,
      stack: this.stack,
      cause: this.cause?.message,
    };
  }
}

/**
 * バリデーションエラー
 */
export class ValidationError extends AppError {
  constructor(
    message: string,
    fieldErrors?: Record<string, string[]>
  ) {
    super('VAL_001', { message, fieldErrors });
    this.name = 'ValidationError';
  }
}

/**
 * 認証エラー
 */
export class AuthenticationError extends AppError {
  constructor(errorCode: 'AUTH_001' | 'AUTH_002' | 'AUTH_003' | 'AUTH_004' = 'AUTH_001') {
    super(errorCode);
    this.name = 'AuthenticationError';
  }
}

/**
 * リソース未検出エラー
 */
export class NotFoundError extends AppError {
  constructor(resource: string, id?: string) {
    super('SES_001', { resource, id });
    this.message = `${resource}が見つかりません`;
    this.name = 'NotFoundError';
  }
}
```

### 10.3 グローバルエラーハンドラー

```typescript
// src/errors/errorHandler.ts

import { AppError } from './AppError';

/**
 * Edge Function用エラーハンドラー
 */
export function handleEdgeFunctionError(error: unknown): Response {
  console.error('Edge Function Error:', error);

  if (error instanceof AppError) {
    return new Response(
      JSON.stringify(error.toJSON()),
      {
        status: error.httpStatus,
        headers: { 'Content-Type': 'application/json' },
      }
    );
  }

  // 予期しないエラー
  const appError = new AppError('SYS_001', { 
    originalMessage: error instanceof Error ? error.message : 'Unknown error' 
  });
  
  return new Response(
    JSON.stringify(appError.toJSON()),
    {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    }
  );
}

/**
 * React Native用エラーハンドラー
 */
export function handleClientError(error: unknown): {
  code: string;
  message: string;
  isRetryable: boolean;
} {
  if (error instanceof AppError) {
    return {
      code: error.code,
      message: error.message,
      isRetryable: isRetryableError(error.code),
    };
  }

  // ネットワークエラーの検出
  if (error instanceof TypeError && error.message.includes('fetch')) {
    return {
      code: 'NET_001',
      message: 'ネットワークに接続できません',
      isRetryable: true,
    };
  }

  return {
    code: 'SYS_001',
    message: 'エラーが発生しました',
    isRetryable: false,
  };
}

/**
 * リトライ可能なエラーか判定
 */
function isRetryableError(code: string): boolean {
  const retryableCodes = [
    'AI_002',   // レート制限
    'AI_003',   // タイムアウト
    'DIA_001',  // 話者分離失敗
    'DIA_002',  // 話者分離タイムアウト
    'DIA_003',  // サーバー接続失敗
    'DB_001',   // DB接続失敗
    'NET_001',  // ネットワーク接続失敗
    'NET_002',  // ネットワークタイムアウト
    'STR_001',  // アップロード失敗
  ];
  
  return retryableCodes.includes(code);
}
```

### 10.4 リトライユーティリティ

```typescript
// src/utils/retry.ts

interface RetryOptions {
  maxAttempts: number;
  initialDelay: number;
  maxDelay: number;
  backoffFactor: number;
  jitter: boolean;
  retryCondition?: (error: any) => boolean;
  onRetry?: (attempt: number, error: any, delay: number) => void;
}

const defaultOptions: RetryOptions = {
  maxAttempts: 3,
  initialDelay: 1000,
  maxDelay: 30000,
  backoffFactor: 2,
  jitter: true,
};

/**
 * リトライ付き関数実行
 */
export async function withRetry<T>(
  fn: () => Promise<T>,
  options: Partial<RetryOptions> = {}
): Promise<T> {
  const opts = { ...defaultOptions, ...options };
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error: any) {
      lastError = error;

      // リトライ条件チェック
      if (opts.retryCondition && !opts.retryCondition(error)) {
        throw error;
      }

      // 最後の試行ならエラーをスロー
      if (attempt === opts.maxAttempts) {
        throw error;
      }

      // 遅延計算
      let delay = Math.min(
        opts.initialDelay * Math.pow(opts.backoffFactor, attempt - 1),
        opts.maxDelay
      );

      // ジッター追加
      if (opts.jitter) {
        delay += Math.random() * 1000;
      }

      // コールバック
      opts.onRetry?.(attempt, error, delay);

      // 待機
      await sleep(delay);
    }
  }

  throw lastError;
}

function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * 使用例
 */
export const retryPresets = {
  // Claude API用
  claudeApi: {
    maxAttempts: 3,
    initialDelay: 2000,
    maxDelay: 60000,
    backoffFactor: 2,
    jitter: true,
    retryCondition: (error: any) => {
      return error.status === 429 || error.status >= 500;
    },
  },

  // pyannote Server用
  pyannote: {
    maxAttempts: 2,
    initialDelay: 5000,
    maxDelay: 30000,
    backoffFactor: 2,
    jitter: false,
  },

  // データベース用
  database: {
    maxAttempts: 3,
    initialDelay: 1000,
    maxDelay: 10000,
    backoffFactor: 2,
    jitter: true,
    retryCondition: (error: any) => {
      return error.code === 'ECONNRESET' || error.message?.includes('connection');
    },
  },
};
```

---
