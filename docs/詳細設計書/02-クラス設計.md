## 2. クラス設計

### 2.1 ドメインモデル概要

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           ドメインモデル概要図                               │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                        Bounded Context: Salon                        │   │
│  │                                                                     │   │
│  │   ┌─────────────┐         ┌─────────────┐                          │   │
│  │   │   Salon     │◆────────│   Staff     │                          │   │
│  │   │ (Aggregate) │   1:n   │  (Entity)   │                          │   │
│  │   └─────────────┘         └─────────────┘                          │   │
│  │         │                       │                                   │   │
│  │         │                       │ 1:n                               │   │
│  │         │                       ▼                                   │   │
│  │         │               ┌─────────────┐                             │   │
│  │         │               │  StaffRole  │                             │   │
│  │         │               │(ValueObject)│                             │   │
│  │         │               └─────────────┘                             │   │
│  │         │                                                           │   │
│  └─────────┼───────────────────────────────────────────────────────────┘   │
│            │                                                               │
│  ┌─────────┼───────────────────────────────────────────────────────────┐   │
│  │         │            Bounded Context: Session                       │   │
│  │         │                                                           │   │
│  │         │ 1:n    ┌─────────────┐                                    │   │
│  │         └───────▶│   Session   │◆─────────┬─────────┬─────────┐    │   │
│  │                  │ (Aggregate) │   1:n    │   1:n   │   1:1   │    │   │
│  │                  └─────────────┘          │         │         │    │   │
│  │                        │                  │         │         │    │   │
│  │                        │            ┌─────┴───┐ ┌───┴───┐ ┌───┴──┐│   │
│  │                        │            │Transcript│ │Analysis│ │Report││   │
│  │                        │            │ (Entity) │ │(Entity)│ │(Ent.)││   │
│  │                        │            └─────────┘ └────────┘ └──────┘│   │
│  │                        │                                            │   │
│  │                  ┌─────┴─────┐                                      │   │
│  │                  │  Speaker  │                                      │   │
│  │                  │  Segment  │                                      │   │
│  │                  │ (Entity)  │                                      │   │
│  │                  └───────────┘                                      │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Bounded Context: Analysis                        │   │
│  │                                                                     │   │
│  │   ┌─────────────┐                                                   │   │
│  │   │AnalysisResult│                                                  │   │
│  │   │ (Aggregate) │                                                   │   │
│  │   └──────┬──────┘                                                   │   │
│  │          │                                                          │   │
│  │    ┌─────┴─────┬─────────────┬─────────────┬─────────────┐         │   │
│  │    │           │             │             │             │         │   │
│  │    ▼           ▼             ▼             ▼             ▼         │   │
│  │ ┌────────┐ ┌────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐      │   │
│  │ │TalkRatio│ │Question│ │ Emotion  │ │ Concern  │ │Conversion│      │   │
│  │ │ (VO)   │ │Analysis│ │ Analysis │ │ Keywords │ │  (VO)    │      │   │
│  │ └────────┘ │ (VO)   │ │  (VO)    │ │  (VO)    │ └──────────┘      │   │
│  │            └────────┘ └──────────┘ └──────────┘                    │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Bounded Context: SuccessCase                     │   │
│  │                                                                     │   │
│  │   ┌─────────────┐         ┌─────────────┐                          │   │
│  │   │ SuccessCase │◆────────│  Embedding  │                          │   │
│  │   │ (Aggregate) │   1:1   │(ValueObject)│                          │   │
│  │   └─────────────┘         └─────────────┘                          │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                    Bounded Context: Training                        │   │
│  │                                                                     │   │
│  │   ┌─────────────┐         ┌─────────────┐                          │   │
│  │   │  Scenario   │         │  Roleplay   │                          │   │
│  │   │ (Aggregate) │         │  Session    │                          │   │
│  │   └─────────────┘         │ (Aggregate) │                          │   │
│  │                           └──────┬──────┘                          │   │
│  │                                  │                                  │   │
│  │                           ┌──────┴──────┐                          │   │
│  │                           │  Evaluation │                          │   │
│  │                           │(ValueObject)│                          │   │
│  │                           └─────────────┘                          │   │
│  │                                                                     │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  凡例:                                                                      │
│  ┌───┐ Aggregate Root    ◆──── 集約関係                                   │
│  └───┘                   ────▶ 参照関係                                    │
│  (VO) = Value Object                                                       │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 エンティティ定義

#### 2.2.1 Salon（店舗）

```typescript
// src/domain/entities/Salon.ts

import { SalonId, SalonSettings, Plan } from '../valueObjects';

/**
 * 店舗エンティティ
 * 集約ルート
 */
export interface Salon {
  readonly id: SalonId;
  readonly name: string;
  readonly address: string | null;
  readonly phone: string | null;
  readonly plan: Plan;
  readonly seatsCount: number | null;
  readonly settings: SalonSettings;
  readonly createdAt: Date;
  readonly updatedAt: Date;
}

/**
 * 店舗作成パラメータ
 */
export interface CreateSalonParams {
  name: string;
  address?: string;
  phone?: string;
  plan?: Plan;
  seatsCount?: number;
  settings?: Partial<SalonSettings>;
}

/**
 * 店舗更新パラメータ
 */
export interface UpdateSalonParams {
  name?: string;
  address?: string;
  phone?: string;
  plan?: Plan;
  seatsCount?: number;
  settings?: Partial<SalonSettings>;
}

/**
 * 店舗ドメインサービス
 */
export const SalonDomain = {
  /**
   * 店舗を作成
   */
  create(params: CreateSalonParams): Omit<Salon, 'id' | 'createdAt' | 'updatedAt'> {
    return {
      name: params.name,
      address: params.address ?? null,
      phone: params.phone ?? null,
      plan: params.plan ?? 'standard',
      seatsCount: params.seatsCount ?? null,
      settings: {
        notification: {
          enablePush: true,
          enableEmail: true,
          concernDetectionAlert: true,
          sessionCompleteAlert: true,
        },
        analysis: {
          idealTalkRatio: 40,
          minQuestionCount: 8,
          concernKeywords: ['乾燥', '広がり', 'パサつき', 'ダメージ', 'うねり', '薄毛', '白髪'],
        },
        display: {
          showRanking: true,
          anonymizeCustomer: false,
        },
        ...params.settings,
      },
    };
  },

  /**
   * プランの機能制限を確認
   */
  canUseFeature(salon: Salon, feature: keyof PlanFeatures): boolean {
    const planFeatures: Record<Plan, PlanFeatures> = {
      standard: {
        aiAnalysis: true,
        realtimeAssist: true,
        report: true,
        training: false,
        apiAccess: false,
        maxSessions: 100,
        maxStaff: 10,
      },
      professional: {
        aiAnalysis: true,
        realtimeAssist: true,
        report: true,
        training: true,
        apiAccess: false,
        maxSessions: 500,
        maxStaff: 30,
      },
      enterprise: {
        aiAnalysis: true,
        realtimeAssist: true,
        report: true,
        training: true,
        apiAccess: true,
        maxSessions: -1, // 無制限
        maxStaff: -1,
      },
    };
    return planFeatures[salon.plan][feature];
  },

  /**
   * スタッフ上限を確認
   */
  canAddStaff(salon: Salon, currentStaffCount: number): boolean {
    const maxStaff = this.getMaxStaff(salon);
    return maxStaff === -1 || currentStaffCount < maxStaff;
  },

  /**
   * 最大スタッフ数を取得
   */
  getMaxStaff(salon: Salon): number {
    const limits: Record<Plan, number> = {
      standard: 10,
      professional: 30,
      enterprise: -1,
    };
    return limits[salon.plan];
  },
};

interface PlanFeatures {
  aiAnalysis: boolean;
  realtimeAssist: boolean;
  report: boolean;
  training: boolean;
  apiAccess: boolean;
  maxSessions: number;
  maxStaff: number;
}
```

#### 2.2.2 Staff（スタッフ）

```typescript
// src/domain/entities/Staff.ts

import { StaffId, SalonId, AuthUserId, StaffRole, StaffSettings } from '../valueObjects';

/**
 * スタッフエンティティ
 */
export interface Staff {
  readonly id: StaffId;
  readonly salonId: SalonId;
  readonly authUserId: AuthUserId;
  readonly name: string;
  readonly email: string;
  readonly role: StaffRole;
  readonly position: string | null;
  readonly joinDate: Date | null;
  readonly profileImageUrl: string | null;
  readonly settings: StaffSettings;
  readonly isActive: boolean;
  readonly createdAt: Date;
  readonly updatedAt: Date;
}

/**
 * スタッフ作成パラメータ
 */
export interface CreateStaffParams {
  salonId: SalonId;
  authUserId: AuthUserId;
  name: string;
  email: string;
  role: StaffRole;
  position?: string;
  joinDate?: Date;
}

/**
 * スタッフ更新パラメータ
 */
export interface UpdateStaffParams {
  name?: string;
  role?: StaffRole;
  position?: string;
  joinDate?: Date;
  profileImageUrl?: string;
  settings?: Partial<StaffSettings>;
  isActive?: boolean;
}

/**
 * スタッフドメインサービス
 */
export const StaffDomain = {
  /**
   * スタッフを作成
   */
  create(params: CreateStaffParams): Omit<Staff, 'id' | 'createdAt' | 'updatedAt'> {
    return {
      salonId: params.salonId,
      authUserId: params.authUserId,
      name: params.name,
      email: params.email.toLowerCase(),
      role: params.role,
      position: params.position ?? null,
      joinDate: params.joinDate ?? null,
      profileImageUrl: null,
      settings: {
        notificationPreferences: {
          concernAlert: true,
          sessionComplete: true,
          weeklyReport: true,
        },
        displayPreferences: {
          showScore: true,
          showRanking: true,
        },
      },
      isActive: true,
    };
  },

  /**
   * 権限チェック
   */
  hasPermission(staff: Staff, permission: Permission): boolean {
    const rolePermissions: Record<StaffRole, Permission[]> = {
      owner: [
        'session:create', 'session:read:own', 'session:read:all',
        'report:read:own', 'report:read:all', 'report:export',
        'staff:manage', 'salon:settings',
        'success-case:create', 'success-case:read',
        'training:use', 'dashboard:view', 'analytics:export',
      ],
      manager: [
        'session:create', 'session:read:own', 'session:read:all',
        'report:read:own', 'report:read:all', 'report:export',
        'staff:manage',
        'success-case:create', 'success-case:read',
        'training:use', 'dashboard:view', 'analytics:export',
      ],
      stylist: [
        'session:create', 'session:read:own',
        'report:read:own',
        'success-case:read',
        'training:use',
      ],
      assistant: [
        'session:read:own',
        'report:read:own',
        'success-case:read',
        'training:use',
      ],
    };
    return rolePermissions[staff.role].includes(permission);
  },

  /**
   * 他スタッフのデータにアクセス可能か
   */
  canAccessOtherStaffData(staff: Staff): boolean {
    return staff.role === 'owner' || staff.role === 'manager';
  },

  /**
   * セッション開始可能か
   */
  canStartSession(staff: Staff): boolean {
    return staff.isActive && ['owner', 'manager', 'stylist'].includes(staff.role);
  },
};

type Permission =
  | 'session:create' | 'session:read:own' | 'session:read:all'
  | 'report:read:own' | 'report:read:all' | 'report:export'
  | 'staff:manage' | 'salon:settings'
  | 'success-case:create' | 'success-case:read'
  | 'training:use' | 'dashboard:view' | 'analytics:export';
```

#### 2.2.3 Session（セッション）

```typescript
// src/domain/entities/Session.ts

import { 
  SessionId, SalonId, StaffId, SessionStatus, 
  DiarizationStatus, CustomerInfo 
} from '../valueObjects';

/**
 * セッションエンティティ
 * 集約ルート
 */
export interface Session {
  readonly id: SessionId;
  readonly salonId: SalonId;
  readonly stylistId: StaffId;
  readonly startedAt: Date;
  readonly endedAt: Date | null;
  readonly status: SessionStatus;
  readonly customerInfo: CustomerInfo | null;
  readonly diarizationStatus: DiarizationStatus;
  readonly createdAt: Date;
  readonly updatedAt: Date;
}

/**
 * セッション作成パラメータ
 */
export interface CreateSessionParams {
  salonId: SalonId;
  stylistId: StaffId;
  customerInfo?: CustomerInfo;
}

/**
 * セッションドメインサービス
 */
export const SessionDomain = {
  /**
   * セッションを作成
   */
  create(params: CreateSessionParams): Omit<Session, 'id' | 'createdAt' | 'updatedAt'> {
    return {
      salonId: params.salonId,
      stylistId: params.stylistId,
      startedAt: new Date(),
      endedAt: null,
      status: 'recording',
      customerInfo: params.customerInfo ?? null,
      diarizationStatus: 'pending',
    };
  },

  /**
   * セッションを終了
   */
  end(session: Session): Partial<Session> {
    if (session.status !== 'recording') {
      throw new Error(`Cannot end session with status: ${session.status}`);
    }
    return {
      endedAt: new Date(),
      status: 'processing',
    };
  },

  /**
   * セッション完了
   */
  complete(session: Session): Partial<Session> {
    if (session.status !== 'processing') {
      throw new Error(`Cannot complete session with status: ${session.status}`);
    }
    return {
      status: 'completed',
    };
  },

  /**
   * セッション失敗
   */
  fail(session: Session): Partial<Session> {
    return {
      status: 'failed',
    };
  },

  /**
   * 話者分離ステータス更新
   */
  updateDiarizationStatus(
    session: Session, 
    status: DiarizationStatus
  ): Partial<Session> {
    return {
      diarizationStatus: status,
    };
  },

  /**
   * セッション時間（分）を計算
   */
  getDurationMinutes(session: Session): number {
    const endTime = session.endedAt ?? new Date();
    const diffMs = endTime.getTime() - session.startedAt.getTime();
    return Math.floor(diffMs / 1000 / 60);
  },

  /**
   * セッションがアクティブか
   */
  isActive(session: Session): boolean {
    return session.status === 'recording';
  },

  /**
   * Realtimeチャンネル名を生成
   */
  getRealtimeChannel(session: Session): string {
    return `session:${session.id}`;
  },

  /**
   * 音声保存パスを生成
   */
  getAudioPath(session: Session, chunkIndex: number): string {
    const date = session.startedAt.toISOString().split('T')[0];
    return `${session.salonId}/${date}/${session.id}/chunk_${chunkIndex.toString().padStart(4, '0')}.wav`;
  },
};
```

#### 2.2.4 Transcript（文字起こし）

```typescript
// src/domain/entities/Transcript.ts

import { TranscriptId, SessionId } from '../valueObjects';

/**
 * 文字起こしエンティティ
 */
export interface Transcript {
  readonly id: TranscriptId;
  readonly sessionId: SessionId;
  readonly chunkIndex: number;
  readonly text: string;
  readonly startTime: number;  // 秒
  readonly endTime: number;    // 秒
  readonly audioUrl: string | null;
  readonly createdAt: Date;
}

/**
 * 文字起こし作成パラメータ
 */
export interface CreateTranscriptParams {
  sessionId: SessionId;
  chunkIndex: number;
  text: string;
  startTime: number;
  endTime: number;
  audioUrl?: string;
}

/**
 * 文字起こしドメインサービス
 */
export const TranscriptDomain = {
  /**
   * 文字起こしを作成
   */
  create(params: CreateTranscriptParams): Omit<Transcript, 'id' | 'createdAt'> {
    return {
      sessionId: params.sessionId,
      chunkIndex: params.chunkIndex,
      text: params.text.trim(),
      startTime: params.startTime,
      endTime: params.endTime,
      audioUrl: params.audioUrl ?? null,
    };
  },

  /**
   * 時間範囲が妥当か検証
   */
  isValidTimeRange(startTime: number, endTime: number): boolean {
    return startTime >= 0 && endTime > startTime;
  },

  /**
   * 発話時間（秒）を計算
   */
  getDuration(transcript: Transcript): number {
    return transcript.endTime - transcript.startTime;
  },

  /**
   * 複数のTranscriptをマージ
   */
  mergeTexts(transcripts: Transcript[]): string {
    return transcripts
      .sort((a, b) => a.chunkIndex - b.chunkIndex)
      .map(t => t.text)
      .join(' ');
  },
};
```

#### 2.2.5 SpeakerSegment（話者セグメント）

```typescript
// src/domain/entities/SpeakerSegment.ts

import { SpeakerSegmentId, SessionId, Speaker } from '../valueObjects';

/**
 * 話者セグメントエンティティ
 */
export interface SpeakerSegment {
  readonly id: SpeakerSegmentId;
  readonly sessionId: SessionId;
  readonly speaker: Speaker;
  readonly startTime: number;  // 秒
  readonly endTime: number;    // 秒
  readonly text: string | null;
  readonly confidence: number | null;
  readonly createdAt: Date;
}

/**
 * 話者セグメント作成パラメータ
 */
export interface CreateSpeakerSegmentParams {
  sessionId: SessionId;
  speaker: Speaker;
  startTime: number;
  endTime: number;
  text?: string;
  confidence?: number;
}

/**
 * 話者セグメントドメインサービス
 */
export const SpeakerSegmentDomain = {
  /**
   * 話者セグメントを作成
   */
  create(params: CreateSpeakerSegmentParams): Omit<SpeakerSegment, 'id' | 'createdAt'> {
    return {
      sessionId: params.sessionId,
      speaker: params.speaker,
      startTime: params.startTime,
      endTime: params.endTime,
      text: params.text ?? null,
      confidence: params.confidence ?? null,
    };
  },

  /**
   * pyannoteの結果をSpeakerに変換
   * SPEAKER_00 -> stylist, SPEAKER_01 -> customer
   * （最初に話した方をスタイリストと仮定）
   */
  mapPyannoteLabel(label: string, isFirstSpeaker: boolean): Speaker {
    // 最初に発話した方をスタイリストとする（施術開始時は美容師が話しかける）
    if (isFirstSpeaker) {
      return label === 'SPEAKER_00' ? 'stylist' : 'customer';
    }
    return label === 'SPEAKER_00' ? 'customer' : 'stylist';
  },

  /**
   * 発話時間を計算
   */
  getDuration(segment: SpeakerSegment): number {
    return segment.endTime - segment.startTime;
  },

  /**
   * 話者別の発話時間を集計
   */
  calculateTalkTime(segments: SpeakerSegment[]): { stylist: number; customer: number } {
    return segments.reduce(
      (acc, segment) => {
        const duration = this.getDuration(segment);
        if (segment.speaker === 'stylist') {
          acc.stylist += duration;
        } else if (segment.speaker === 'customer') {
          acc.customer += duration;
        }
        return acc;
      },
      { stylist: 0, customer: 0 }
    );
  },

  /**
   * テキストと話者情報をマージ
   */
  mergeWithTranscripts(
    segments: SpeakerSegment[],
    transcripts: Transcript[]
  ): TranscriptWithSpeaker[] {
    const result: TranscriptWithSpeaker[] = [];
    
    for (const segment of segments) {
      // セグメントの時間範囲に含まれるテキストを取得
      const matchingTranscripts = transcripts.filter(
        t => t.startTime >= segment.startTime && t.endTime <= segment.endTime
      );
      
      if (matchingTranscripts.length > 0) {
        result.push({
          speaker: segment.speaker,
          text: matchingTranscripts.map(t => t.text).join(' '),
          startTime: segment.startTime,
          endTime: segment.endTime,
        });
      } else if (segment.text) {
        result.push({
          speaker: segment.speaker,
          text: segment.text,
          startTime: segment.startTime,
          endTime: segment.endTime,
        });
      }
    }
    
    return result.sort((a, b) => a.startTime - b.startTime);
  },
};

interface TranscriptWithSpeaker {
  speaker: Speaker;
  text: string;
  startTime: number;
  endTime: number;
}
```

#### 2.2.6 SessionAnalysis（セッション分析）

```typescript
// src/domain/entities/SessionAnalysis.ts

import { 
  SessionAnalysisId, SessionId, IndicatorType, 
  AnalysisDetails 
} from '../valueObjects';

/**
 * セッション分析エンティティ
 */
export interface SessionAnalysis {
  readonly id: SessionAnalysisId;
  readonly sessionId: SessionId;
  readonly chunkIndex: number;
  readonly indicatorType: IndicatorType;
  readonly value: number;
  readonly score: number;  // 0-100
  readonly details: AnalysisDetails;
  readonly createdAt: Date;
}

/**
 * セッション分析作成パラメータ
 */
export interface CreateSessionAnalysisParams {
  sessionId: SessionId;
  chunkIndex: number;
  indicatorType: IndicatorType;
  value: number;
  score: number;
  details: AnalysisDetails;
}

/**
 * 分析結果をまとめた型
 */
export interface AnalysisResultSet {
  talkRatio: SessionAnalysis | null;
  questionAnalysis: SessionAnalysis | null;
  emotionAnalysis: SessionAnalysis | null;
  concernKeywords: SessionAnalysis | null;
  proposalTiming: SessionAnalysis | null;
  proposalQuality: SessionAnalysis | null;
  conversion: SessionAnalysis | null;
}

/**
 * セッション分析ドメインサービス
 */
export const SessionAnalysisDomain = {
  /**
   * 分析結果を作成
   */
  create(params: CreateSessionAnalysisParams): Omit<SessionAnalysis, 'id' | 'createdAt'> {
    // スコアは0-100の範囲に正規化
    const normalizedScore = Math.max(0, Math.min(100, Math.round(params.score)));
    
    return {
      sessionId: params.sessionId,
      chunkIndex: params.chunkIndex,
      indicatorType: params.indicatorType,
      value: params.value,
      score: normalizedScore,
      details: params.details,
    };
  },

  /**
   * 総合スコアを計算
   */
  calculateOverallScore(analyses: AnalysisResultSet): number {
    const weights: Record<IndicatorType, number> = {
      talk_ratio: 0.15,
      question_analysis: 0.15,
      emotion_analysis: 0.15,
      concern_keywords: 0.10,
      proposal_timing: 0.15,
      proposal_quality: 0.15,
      conversion: 0.15,
    };

    let totalScore = 0;
    let totalWeight = 0;

    const analysisArray = [
      { type: 'talk_ratio' as const, analysis: analyses.talkRatio },
      { type: 'question_analysis' as const, analysis: analyses.questionAnalysis },
      { type: 'emotion_analysis' as const, analysis: analyses.emotionAnalysis },
      { type: 'concern_keywords' as const, analysis: analyses.concernKeywords },
      { type: 'proposal_timing' as const, analysis: analyses.proposalTiming },
      { type: 'proposal_quality' as const, analysis: analyses.proposalQuality },
      { type: 'conversion' as const, analysis: analyses.conversion },
    ];

    for (const { type, analysis } of analysisArray) {
      if (analysis) {
        totalScore += analysis.score * weights[type];
        totalWeight += weights[type];
      }
    }

    // 重みの合計で正規化
    return totalWeight > 0 ? Math.round(totalScore / totalWeight * 100) / 100 : 0;
  },

  /**
   * 指標別スコアマップを生成
   */
  toIndicatorScoreMap(analyses: SessionAnalysis[]): Record<IndicatorType, { score: number; value: number }> {
    const result: Partial<Record<IndicatorType, { score: number; value: number }>> = {};
    
    for (const analysis of analyses) {
      result[analysis.indicatorType] = {
        score: analysis.score,
        value: analysis.value,
      };
    }
    
    return result as Record<IndicatorType, { score: number; value: number }>;
  },

  /**
   * 最新のチャンク分析を取得
   */
  getLatestByChunk(analyses: SessionAnalysis[]): Map<IndicatorType, SessionAnalysis> {
    const latest = new Map<IndicatorType, SessionAnalysis>();
    
    for (const analysis of analyses) {
      const existing = latest.get(analysis.indicatorType);
      if (!existing || analysis.chunkIndex > existing.chunkIndex) {
        latest.set(analysis.indicatorType, analysis);
      }
    }
    
    return latest;
  },
};
```

#### 2.2.7 SessionReport（セッションレポート）

```typescript
// src/domain/entities/SessionReport.ts

import { 
  SessionReportId, SessionId, IndicatorScores 
} from '../valueObjects';

/**
 * セッションレポートエンティティ
 */
export interface SessionReport {
  readonly id: SessionReportId;
  readonly sessionId: SessionId;
  readonly overallScore: number;
  readonly goodPoints: string[];
  readonly improvementPoints: string[];
  readonly actionItems: string[];
  readonly transcriptSummary: string | null;
  readonly aiFeedback: string | null;
  readonly indicatorScores: IndicatorScores;
  readonly createdAt: Date;
}

/**
 * セッションレポート作成パラメータ
 */
export interface CreateSessionReportParams {
  sessionId: SessionId;
  overallScore: number;
  goodPoints: string[];
  improvementPoints: string[];
  actionItems: string[];
  transcriptSummary?: string;
  aiFeedback?: string;
  indicatorScores: IndicatorScores;
}

/**
 * セッションレポートドメインサービス
 */
export const SessionReportDomain = {
  /**
   * レポートを作成
   */
  create(params: CreateSessionReportParams): Omit<SessionReport, 'id' | 'createdAt'> {
    return {
      sessionId: params.sessionId,
      overallScore: Math.max(0, Math.min(100, Math.round(params.overallScore))),
      goodPoints: params.goodPoints.slice(0, 5),  // 最大5つ
      improvementPoints: params.improvementPoints.slice(0, 5),
      actionItems: params.actionItems.slice(0, 5),
      transcriptSummary: params.transcriptSummary ?? null,
      aiFeedback: params.aiFeedback ?? null,
      indicatorScores: params.indicatorScores,
    };
  },

  /**
   * スコアのランクを取得
   */
  getScoreRank(report: SessionReport): ScoreRank {
    if (report.overallScore >= 90) return 'S';
    if (report.overallScore >= 80) return 'A';
    if (report.overallScore >= 70) return 'B';
    if (report.overallScore >= 60) return 'C';
    return 'D';
  },

  /**
   * 最も改善が必要な指標を取得
   */
  getWeakestIndicator(report: SessionReport): IndicatorType | null {
    let weakest: IndicatorType | null = null;
    let lowestScore = 101;

    for (const [type, data] of Object.entries(report.indicatorScores)) {
      if (data.score < lowestScore) {
        lowestScore = data.score;
        weakest = type as IndicatorType;
      }
    }

    return weakest;
  },

  /**
   * 最も優れている指標を取得
   */
  getStrongestIndicator(report: SessionReport): IndicatorType | null {
    let strongest: IndicatorType | null = null;
    let highestScore = -1;

    for (const [type, data] of Object.entries(report.indicatorScores)) {
      if (data.score > highestScore) {
        highestScore = data.score;
        strongest = type as IndicatorType;
      }
    }

    return strongest;
  },
};

type ScoreRank = 'S' | 'A' | 'B' | 'C' | 'D';
type IndicatorType = 
  | 'talk_ratio' 
  | 'question_analysis' 
  | 'emotion_analysis' 
  | 'concern_keywords' 
  | 'proposal_timing' 
  | 'proposal_quality' 
  | 'conversion';
```

#### 2.2.8 SuccessCase（成功事例）

```typescript
// src/domain/entities/SuccessCase.ts

import { 
  SuccessCaseId, SalonId, SessionId, StaffId,
  CustomerProfile, Embedding 
} from '../valueObjects';

/**
 * 成功事例エンティティ
 * 集約ルート
 */
export interface SuccessCase {
  readonly id: SuccessCaseId;
  readonly salonId: SalonId;
  readonly sessionId: SessionId | null;
  readonly stylistId: StaffId | null;
  readonly concernKeywords: string[];
  readonly customerProfile: CustomerProfile | null;
  readonly successfulTalk: string;
  readonly keyTactics: string[];
  readonly soldProduct: string | null;
  readonly conversionRate: number | null;
  readonly embedding: Embedding | null;
  readonly isPublic: boolean;
  readonly createdAt: Date;
}

/**
 * 成功事例作成パラメータ
 */
export interface CreateSuccessCaseParams {
  salonId: SalonId;
  sessionId?: SessionId;
  stylistId?: StaffId;
  concernKeywords: string[];
  customerProfile?: CustomerProfile;
  successfulTalk: string;
  keyTactics: string[];
  soldProduct?: string;
  conversionRate?: number;
  isPublic?: boolean;
}

/**
 * 成功事例検索パラメータ
 */
export interface SearchSuccessCaseParams {
  concernKeywords?: string[];
  customerProfile?: Partial<CustomerProfile>;
  embedding?: Embedding;
  limit?: number;
  salonId?: SalonId;
  includePublic?: boolean;
}

/**
 * 成功事例ドメインサービス
 */
export const SuccessCaseDomain = {
  /**
   * 成功事例を作成
   */
  create(params: CreateSuccessCaseParams): Omit<SuccessCase, 'id' | 'createdAt' | 'embedding'> {
    return {
      salonId: params.salonId,
      sessionId: params.sessionId ?? null,
      stylistId: params.stylistId ?? null,
      concernKeywords: params.concernKeywords,
      customerProfile: params.customerProfile ?? null,
      successfulTalk: params.successfulTalk,
      keyTactics: params.keyTactics,
      soldProduct: params.soldProduct ?? null,
      conversionRate: params.conversionRate ?? null,
      isPublic: params.isPublic ?? false,
    };
  },

  /**
   * 検索用テキストを生成（Embedding用）
   */
  generateSearchText(successCase: Omit<SuccessCase, 'id' | 'createdAt' | 'embedding'>): string {
    const parts: string[] = [];
    
    // 悩みキーワード
    if (successCase.concernKeywords.length > 0) {
      parts.push(`悩み: ${successCase.concernKeywords.join(', ')}`);
    }
    
    // お客様属性
    if (successCase.customerProfile) {
      const profile = successCase.customerProfile;
      if (profile.ageGroup) parts.push(`年代: ${profile.ageGroup}`);
      if (profile.gender) parts.push(`性別: ${profile.gender}`);
      if (profile.visitFrequency) parts.push(`来店頻度: ${profile.visitFrequency}`);
    }
    
    // 成功トーク
    parts.push(`トーク: ${successCase.successfulTalk}`);
    
    // キーポイント
    if (successCase.keyTactics.length > 0) {
      parts.push(`ポイント: ${successCase.keyTactics.join(', ')}`);
    }
    
    // 商品
    if (successCase.soldProduct) {
      parts.push(`商品: ${successCase.soldProduct}`);
    }
    
    return parts.join('\n');
  },

  /**
   * 類似度スコアを計算（コサイン類似度）
   */
  calculateSimilarity(embedding1: number[], embedding2: number[]): number {
    if (embedding1.length !== embedding2.length) {
      throw new Error('Embedding dimensions do not match');
    }
    
    let dotProduct = 0;
    let norm1 = 0;
    let norm2 = 0;
    
    for (let i = 0; i < embedding1.length; i++) {
      dotProduct += embedding1[i] * embedding2[i];
      norm1 += embedding1[i] * embedding1[i];
      norm2 += embedding2[i] * embedding2[i];
    }
    
    return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
  },

  /**
   * 閾値以上の類似度を持つ事例をフィルタリング
   */
  filterBySimilarity(
    cases: Array<SuccessCase & { similarity: number }>,
    threshold: number = 0.7
  ): Array<SuccessCase & { similarity: number }> {
    return cases
      .filter(c => c.similarity >= threshold)
      .sort((a, b) => b.similarity - a.similarity);
  },
};
```

### 2.3 値オブジェクト定義

```typescript
// src/domain/valueObjects/index.ts

/**
 * 識別子型（Branded Types）
 */
export type SalonId = string & { readonly __brand: 'SalonId' };
export type StaffId = string & { readonly __brand: 'StaffId' };
export type SessionId = string & { readonly __brand: 'SessionId' };
export type TranscriptId = string & { readonly __brand: 'TranscriptId' };
export type SpeakerSegmentId = string & { readonly __brand: 'SpeakerSegmentId' };
export type SessionAnalysisId = string & { readonly __brand: 'SessionAnalysisId' };
export type SessionReportId = string & { readonly __brand: 'SessionReportId' };
export type SuccessCaseId = string & { readonly __brand: 'SuccessCaseId' };
export type AuthUserId = string & { readonly __brand: 'AuthUserId' };

/**
 * ID生成ユーティリティ
 */
export const createId = {
  salon: (id: string): SalonId => id as SalonId,
  staff: (id: string): StaffId => id as StaffId,
  session: (id: string): SessionId => id as SessionId,
  transcript: (id: string): TranscriptId => id as TranscriptId,
  speakerSegment: (id: string): SpeakerSegmentId => id as SpeakerSegmentId,
  sessionAnalysis: (id: string): SessionAnalysisId => id as SessionAnalysisId,
  sessionReport: (id: string): SessionReportId => id as SessionReportId,
  successCase: (id: string): SuccessCaseId => id as SuccessCaseId,
  authUser: (id: string): AuthUserId => id as AuthUserId,
};

/**
 * プラン
 * ⚠️ 実装に合わせて修正（2025-12-05）: free追加、professional→premium
 */
export type Plan = 'free' | 'standard' | 'premium' | 'enterprise';

export const PlanDisplay: Record<Plan, string> = {
  free: 'フリー',
  standard: 'スタンダード',
  premium: 'プレミアム',
  enterprise: 'エンタープライズ',
};

/**
 * スタッフロール
 * ⚠️ 実装に合わせて修正（2025-12-05）: assistant→admin
 */
export type StaffRole = 'owner' | 'manager' | 'stylist' | 'admin';

export const StaffRoleDisplay: Record<StaffRole, string> = {
  owner: 'オーナー',
  manager: 'マネージャー',
  stylist: 'スタイリスト',
  admin: '管理者',
};

/**
 * セッションステータス
 * ⚠️ 実装に合わせて修正（2025-12-05）: analyzing追加、failed→error
 */
export type SessionStatus = 'recording' | 'processing' | 'analyzing' | 'completed' | 'error';

export const SessionStatusDisplay: Record<SessionStatus, string> = {
  recording: '録音中',
  processing: '処理中',
  analyzing: '分析中',
  completed: '完了',
  error: 'エラー',
};

/**
 * 話者分離ステータス
 */
export type DiarizationStatus = 'pending' | 'processing' | 'completed' | 'failed';

/**
 * 話者
 */
export type Speaker = 'stylist' | 'customer' | 'unknown';

export const SpeakerDisplay: Record<Speaker, string> = {
  stylist: 'スタイリスト',
  customer: 'お客様',
  unknown: '不明',
};

/**
 * 分析指標タイプ
 */
export type IndicatorType =
  | 'talk_ratio'
  | 'question_analysis'
  | 'emotion_analysis'
  | 'concern_keywords'
  | 'proposal_timing'
  | 'proposal_quality'
  | 'conversion';

export const IndicatorTypeDisplay: Record<IndicatorType, string> = {
  talk_ratio: 'トーク比率',
  question_analysis: '質問分析',
  emotion_analysis: '感情分析',
  concern_keywords: '悩みキーワード',
  proposal_timing: '提案タイミング',
  proposal_quality: '提案品質',
  conversion: '成約判定',
};

/**
 * 年代
 */
export type AgeGroup = '10s' | '20s' | '30s' | '40s' | '50s' | '60s+';

export const AgeGroupDisplay: Record<AgeGroup, string> = {
  '10s': '10代',
  '20s': '20代',
  '30s': '30代',
  '40s': '40代',
  '50s': '50代',
  '60s+': '60代以上',
};

/**
 * 性別
 */
export type Gender = 'male' | 'female' | 'other';

export const GenderDisplay: Record<Gender, string> = {
  male: '男性',
  female: '女性',
  other: 'その他',
};

/**
 * 来店頻度
 */
export type VisitFrequency = 'first' | 'monthly' | 'bimonthly' | 'quarterly' | 'irregular';

export const VisitFrequencyDisplay: Record<VisitFrequency, string> = {
  first: '初めて',
  monthly: '月1回',
  bimonthly: '2ヶ月に1回',
  quarterly: '3ヶ月に1回',
  irregular: '不定期',
};

/**
 * お客様情報
 */
export interface CustomerInfo {
  ageGroup?: AgeGroup;
  gender?: Gender;
  visitFrequency?: VisitFrequency;
  notes?: string;
}

/**
 * お客様プロフィール（成功事例用）
 */
export interface CustomerProfile {
  ageGroup?: AgeGroup;
  gender?: Gender;
  visitFrequency?: VisitFrequency;
  hairType?: string;
  concerns?: string[];
}

/**
 * 店舗設定
 */
export interface SalonSettings {
  notification: {
    enablePush: boolean;
    enableEmail: boolean;
    concernDetectionAlert: boolean;
    sessionCompleteAlert: boolean;
  };
  analysis: {
    idealTalkRatio: number;
    minQuestionCount: number;
    concernKeywords: string[];
  };
  display: {
    showRanking: boolean;
    anonymizeCustomer: boolean;
  };
}

/**
 * スタッフ設定
 */
export interface StaffSettings {
  notificationPreferences: {
    concernAlert: boolean;
    sessionComplete: boolean;
    weeklyReport: boolean;
  };
  displayPreferences: {
    showScore: boolean;
    showRanking: boolean;
  };
}

/**
 * 分析詳細
 */
export interface AnalysisDetails {
  // talk_ratio
  stylistSeconds?: number;
  customerSeconds?: number;
  totalSeconds?: number;
  ratio?: number;
  
  // question_analysis
  totalQuestions?: number;
  openQuestions?: number;
  closedQuestions?: number;
  openRatio?: number;
  questionList?: Array<{
    text: string;
    type: 'open' | 'closed';
    time: number;
  }>;
  
  // emotion_analysis
  positiveRatio?: number;
  keywords?: string[];
  overall?: 'positive' | 'neutral' | 'negative';
  
  // concern_keywords
  detected?: boolean;
  detectedKeywords?: string[];
  detectedAt?: number[];
  context?: string;
  
  // proposal_timing
  concernDetectedAt?: number;
  proposalAt?: number;
  timingMinutes?: number;
  
  // proposal_quality
  hasProposal?: boolean;
  benefitRatio?: number;
  proposalDetails?: string[];
  
  // conversion
  converted?: boolean;
  productName?: string | null;
}

/**
 * 指標スコア（レポート用）
 */
export interface IndicatorScores {
  talk_ratio?: { score: number; value: number };
  question_analysis?: { score: number; value: number };
  emotion_analysis?: { score: number; value: number };
  concern_keywords?: { score: number; value: number };
  proposal_timing?: { score: number; value: number };
  proposal_quality?: { score: number; value: number };
  conversion?: { score: number; value: number };
}

/**
 * ベクトル埋め込み
 */
export type Embedding = number[];

/**
 * Embedding次元数
 */
export const EMBEDDING_DIMENSION = 1536;

/**
 * Embeddingバリデーション
 */
export const isValidEmbedding = (embedding: unknown): embedding is Embedding => {
  return (
    Array.isArray(embedding) &&
    embedding.length === EMBEDDING_DIMENSION &&
    embedding.every(v => typeof v === 'number' && !isNaN(v))
  );
};
```

### 2.4 リポジトリインターフェース

```typescript
// src/domain/repositories/index.ts

import { 
  Salon, CreateSalonParams, UpdateSalonParams,
  Staff, CreateStaffParams, UpdateStaffParams,
  Session, CreateSessionParams,
  Transcript, CreateTranscriptParams,
  SpeakerSegment, CreateSpeakerSegmentParams,
  SessionAnalysis, CreateSessionAnalysisParams,
  SessionReport, CreateSessionReportParams,
  SuccessCase, CreateSuccessCaseParams, SearchSuccessCaseParams,
} from '../entities';
import { 
  SalonId, StaffId, SessionId, AuthUserId, 
  Embedding, IndicatorType 
} from '../valueObjects';

/**
 * 店舗リポジトリ
 */
export interface SalonRepository {
  findById(id: SalonId): Promise<Salon | null>;
  create(params: CreateSalonParams): Promise<Salon>;
  update(id: SalonId, params: UpdateSalonParams): Promise<Salon>;
  delete(id: SalonId): Promise<void>;
}

/**
 * スタッフリポジトリ
 */
export interface StaffRepository {
  findById(id: StaffId): Promise<Staff | null>;
  findByAuthUserId(authUserId: AuthUserId): Promise<Staff | null>;
  findBySalonId(salonId: SalonId): Promise<Staff[]>;
  findActiveByRole(salonId: SalonId, role: Staff['role']): Promise<Staff[]>;
  create(params: CreateStaffParams): Promise<Staff>;
  update(id: StaffId, params: UpdateStaffParams): Promise<Staff>;
  delete(id: StaffId): Promise<void>;
  countBySalonId(salonId: SalonId): Promise<number>;
}

/**
 * セッションリポジトリ
 */
export interface SessionRepository {
  findById(id: SessionId): Promise<Session | null>;
  findByStylistId(stylistId: StaffId, options?: { 
    limit?: number; 
    offset?: number;
    status?: Session['status'];
  }): Promise<Session[]>;
  findBySalonId(salonId: SalonId, options?: {
    limit?: number;
    offset?: number;
    status?: Session['status'];
    startDate?: Date;
    endDate?: Date;
  }): Promise<Session[]>;
  findActiveByStylisId(stylistId: StaffId): Promise<Session | null>;
  create(params: CreateSessionParams): Promise<Session>;
  update(id: SessionId, params: Partial<Session>): Promise<Session>;
  countBySalonId(salonId: SalonId, options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<number>;
}

/**
 * 文字起こしリポジトリ
 */
export interface TranscriptRepository {
  findBySessionId(sessionId: SessionId): Promise<Transcript[]>;
  findBySessionIdAndChunk(sessionId: SessionId, chunkIndex: number): Promise<Transcript | null>;
  create(params: CreateTranscriptParams): Promise<Transcript>;
  createMany(params: CreateTranscriptParams[]): Promise<Transcript[]>;
}

/**
 * 話者セグメントリポジトリ
 */
export interface SpeakerSegmentRepository {
  findBySessionId(sessionId: SessionId): Promise<SpeakerSegment[]>;
  create(params: CreateSpeakerSegmentParams): Promise<SpeakerSegment>;
  createMany(params: CreateSpeakerSegmentParams[]): Promise<SpeakerSegment[]>;
  deleteBySessionId(sessionId: SessionId): Promise<void>;
}

/**
 * セッション分析リポジトリ
 */
export interface SessionAnalysisRepository {
  findBySessionId(sessionId: SessionId): Promise<SessionAnalysis[]>;
  findBySessionIdAndChunk(sessionId: SessionId, chunkIndex: number): Promise<SessionAnalysis[]>;
  findLatestBySessionId(sessionId: SessionId): Promise<Map<IndicatorType, SessionAnalysis>>;
  create(params: CreateSessionAnalysisParams): Promise<SessionAnalysis>;
  createMany(params: CreateSessionAnalysisParams[]): Promise<SessionAnalysis[]>;
}

/**
 * セッションレポートリポジトリ
 */
export interface SessionReportRepository {
  findBySessionId(sessionId: SessionId): Promise<SessionReport | null>;
  findByStylistId(stylistId: StaffId, options?: {
    limit?: number;
    offset?: number;
    startDate?: Date;
    endDate?: Date;
  }): Promise<SessionReport[]>;
  create(params: CreateSessionReportParams): Promise<SessionReport>;
  getAverageScoreByStylisId(stylistId: StaffId, options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<number>;
  getAverageScoreBySalonId(salonId: SalonId, options?: {
    startDate?: Date;
    endDate?: Date;
  }): Promise<number>;
}

/**
 * 成功事例リポジトリ
 */
export interface SuccessCaseRepository {
  findById(id: SuccessCaseId): Promise<SuccessCase | null>;
  findBySalonId(salonId: SalonId, options?: {
    limit?: number;
    offset?: number;
  }): Promise<SuccessCase[]>;
  findPublic(options?: {
    limit?: number;
    offset?: number;
  }): Promise<SuccessCase[]>;
  searchByEmbedding(embedding: Embedding, options: {
    salonId?: SalonId;
    includePublic?: boolean;
    limit?: number;
    threshold?: number;
  }): Promise<Array<SuccessCase & { similarity: number }>>;
  searchByKeywords(keywords: string[], options: {
    salonId?: SalonId;
    includePublic?: boolean;
    limit?: number;
  }): Promise<SuccessCase[]>;
  create(params: CreateSuccessCaseParams): Promise<SuccessCase>;
  updateEmbedding(id: SuccessCaseId, embedding: Embedding): Promise<SuccessCase>;
  delete(id: SuccessCaseId): Promise<void>;
}
```

---

（続きは Part 2 に記載: API詳細仕様）
# 詳細設計書 Part 2: API詳細仕様

---
