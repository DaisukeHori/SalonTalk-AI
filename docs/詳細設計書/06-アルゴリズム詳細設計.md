## 6. アルゴリズム詳細設計

### 6.1 分析指標計算アルゴリズム

#### 6.1.1 トーク比率（Talk Ratio）計算

**目的**: スタイリストとお客様の発話時間比率を計算し、理想的な比率（40:60）との乖離を評価

**入力**:
- `segments: SpeakerSegment[]` - 話者分離済みセグメント配列

**出力**:
- `score: number` - 0-100のスコア
- `value: number` - スタイリストの発話比率（%）
- `details: TalkRatioDetails` - 詳細データ

**アルゴリズム**:

```typescript
// src/domain/services/analysis/talkRatioAnalyzer.ts

interface TalkRatioResult {
  score: number;
  value: number;
  details: {
    stylistSeconds: number;
    customerSeconds: number;
    totalSeconds: number;
    ratio: number;
  };
}

/**
 * トーク比率分析
 * 
 * スコア計算ロジック:
 * - 理想比率: 40% (スタイリスト) : 60% (お客様)
 * - 35-45%: 100点（理想範囲）
 * - 30-35% or 45-50%: 80点（許容範囲）
 * - 25-30% or 50-55%: 60点（やや乖離）
 * - それ以外: 40点（大きく乖離）
 */
export function analyzeTalkRatio(segments: SpeakerSegment[]): TalkRatioResult {
  // 1. 話者別の発話時間を集計
  let stylistSeconds = 0;
  let customerSeconds = 0;

  for (const segment of segments) {
    const duration = segment.endTime - segment.startTime;
    
    if (segment.speaker === 'stylist') {
      stylistSeconds += duration;
    } else if (segment.speaker === 'customer') {
      customerSeconds += duration;
    }
    // 'unknown'は無視
  }

  const totalSeconds = stylistSeconds + customerSeconds;

  // 2. 発話がない場合のデフォルト処理
  if (totalSeconds === 0) {
    return {
      score: 50,
      value: 50,
      details: {
        stylistSeconds: 0,
        customerSeconds: 0,
        totalSeconds: 0,
        ratio: 50,
      },
    };
  }

  // 3. スタイリストの発話比率を計算
  const ratio = (stylistSeconds / totalSeconds) * 100;

  // 4. スコア計算
  const score = calculateTalkRatioScore(ratio);

  return {
    score,
    value: Math.round(ratio * 100) / 100,
    details: {
      stylistSeconds: Math.round(stylistSeconds * 100) / 100,
      customerSeconds: Math.round(customerSeconds * 100) / 100,
      totalSeconds: Math.round(totalSeconds * 100) / 100,
      ratio: Math.round(ratio * 100) / 100,
    },
  };
}

/**
 * トーク比率からスコアを計算
 */
function calculateTalkRatioScore(ratio: number): number {
  // 理想範囲（35-45%）
  if (ratio >= 35 && ratio <= 45) {
    return 100;
  }
  
  // 許容範囲（30-35% or 45-50%）
  if ((ratio >= 30 && ratio < 35) || (ratio > 45 && ratio <= 50)) {
    return 80;
  }
  
  // やや乖離（25-30% or 50-55%）
  if ((ratio >= 25 && ratio < 30) || (ratio > 50 && ratio <= 55)) {
    return 60;
  }
  
  // 大きく乖離
  return 40;
}

/**
 * フォールバック: 話者分離なしの場合
 * 文字起こしの文字数比率で推定
 */
export function estimateTalkRatioFromText(
  transcripts: Array<{ text: string; speaker?: string }>
): TalkRatioResult {
  // 話者情報がない場合は50:50と仮定
  return {
    score: 50,
    value: 50,
    details: {
      stylistSeconds: 0,
      customerSeconds: 0,
      totalSeconds: 0,
      ratio: 50,
    },
  };
}
```

**フローチャート**:

```
┌─────────────────────────────────────────────────────────────────┐
│                   トーク比率計算フロー                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│    開始                                                         │
│      │                                                          │
│      ▼                                                          │
│  ┌─────────────────┐                                            │
│  │ セグメント取得   │                                            │
│  └────────┬────────┘                                            │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐     No      ┌─────────────────┐           │
│  │ セグメント数 > 0 │────────────▶│ デフォルト値返却 │           │
│  └────────┬────────┘             │ (score=50)      │           │
│           │ Yes                   └─────────────────┘           │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │ 話者別時間集計   │                                            │
│  │ for each segment│                                            │
│  └────────┬────────┘                                            │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │ 比率計算         │                                            │
│  │ ratio = stylist │                                            │
│  │ / total * 100   │                                            │
│  └────────┬────────┘                                            │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────────────────────────────────┐               │
│  │              スコア判定                      │               │
│  │                                             │               │
│  │  35-45% ───────────────────▶ score = 100   │               │
│  │  30-35% or 45-50% ─────────▶ score = 80    │               │
│  │  25-30% or 50-55% ─────────▶ score = 60    │               │
│  │  それ以外 ─────────────────▶ score = 40    │               │
│  │                                             │               │
│  └────────┬────────────────────────────────────┘               │
│           │                                                      │
│           ▼                                                      │
│  ┌─────────────────┐                                            │
│  │ 結果返却         │                                            │
│  └─────────────────┘                                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

#### 6.1.2 質問分析（Question Analysis）

**目的**: スタイリストの質問数と質問の種類（オープン/クローズド）を分析

**入力**:
- `conversationData: ConversationTurn[]` - 話者付き会話データ

**出力**:
- `score: number` - 0-100のスコア
- `value: number` - 質問総数
- `details: QuestionAnalysisDetails` - 詳細データ

**アルゴリズム**:

```typescript
// src/domain/services/analysis/questionAnalyzer.ts

interface QuestionAnalysisResult {
  score: number;
  value: number;
  details: {
    totalQuestions: number;
    openQuestions: number;
    closedQuestions: number;
    openRatio: number;
    questionList: Array<{
      text: string;
      type: 'open' | 'closed';
      time: number;
    }>;
  };
}

/**
 * 質問検出パターン
 */
const QUESTION_PATTERNS = [
  /[？?]$/,                    // 文末に疑問符
  /でしょうか[。]?$/,          // 〜でしょうか
  /ですか[。]?$/,              // 〜ですか
  /ますか[。]?$/,              // 〜ますか
  /ませんか[。]?$/,            // 〜ませんか
  /かな[。]?$/,                // 〜かな
  /かしら[。]?$/,              // 〜かしら
  /の[。]?$/,                  // 〜の？（上昇イントネーション想定）
];

/**
 * オープンクエスチョンパターン
 * What, Why, How系の質問
 */
const OPEN_QUESTION_PATTERNS = [
  /^(どう|どのよう|どんな)/,    // どう〜、どのような〜
  /^何(が|を|に)/,              // 何が〜
  /^なぜ/,                      // なぜ〜
  /^どこ/,                      // どこ〜
  /^いつ/,                      // いつ〜
  /について/,                   // 〜について
  /どう思/,                     // どう思いますか
  /感じ/,                       // どう感じますか
  /ご希望/,                     // ご希望は
  /お悩み/,                     // お悩みは
  /理由/,                       // 理由は
];

/**
 * 質問分析
 * 
 * スコア計算ロジック:
 * - 理想: 質問8-12回、オープンクエスチョン60%以上
 * - 8-12回 & オープン60%以上: 100点
 * - 6-14回 & オープン50%以上: 80点
 * - 4-16回 & オープン40%以上: 60点
 * - それ以外: 40点
 */
export function analyzeQuestions(
  conversationData: ConversationTurn[]
): QuestionAnalysisResult {
  const stylistUtterances = conversationData.filter(
    turn => turn.speaker === 'stylist'
  );

  const questionList: QuestionAnalysisResult['details']['questionList'] = [];
  let totalQuestions = 0;
  let openQuestions = 0;

  for (const utterance of stylistUtterances) {
    // 質問かどうか判定
    const isQuestion = QUESTION_PATTERNS.some(pattern => 
      pattern.test(utterance.text)
    );

    if (isQuestion) {
      totalQuestions++;
      
      // オープンクエスチョンかどうか判定
      const isOpen = OPEN_QUESTION_PATTERNS.some(pattern =>
        pattern.test(utterance.text)
      );

      if (isOpen) {
        openQuestions++;
      }

      questionList.push({
        text: utterance.text,
        type: isOpen ? 'open' : 'closed',
        time: utterance.startTime,
      });
    }
  }

  const closedQuestions = totalQuestions - openQuestions;
  const openRatio = totalQuestions > 0 
    ? (openQuestions / totalQuestions) * 100 
    : 0;

  const score = calculateQuestionScore(totalQuestions, openRatio);

  return {
    score,
    value: totalQuestions,
    details: {
      totalQuestions,
      openQuestions,
      closedQuestions,
      openRatio: Math.round(openRatio * 100) / 100,
      questionList,
    },
  };
}

/**
 * 質問分析スコア計算
 */
function calculateQuestionScore(totalQuestions: number, openRatio: number): number {
  // 理想範囲
  if (totalQuestions >= 8 && totalQuestions <= 12 && openRatio >= 60) {
    return 100;
  }
  
  // 良好範囲
  if (totalQuestions >= 6 && totalQuestions <= 14 && openRatio >= 50) {
    return 80;
  }
  
  // 許容範囲
  if (totalQuestions >= 4 && totalQuestions <= 16 && openRatio >= 40) {
    return 60;
  }
  
  // それ以外
  return 40;
}

interface ConversationTurn {
  speaker: 'stylist' | 'customer' | 'unknown';
  text: string;
  startTime: number;
  endTime: number;
}
```

---

#### 6.1.3 感情分析（Emotion Analysis）

**目的**: お客様の発話から感情（ポジティブ/ネガティブ）を分析

**入力**:
- `conversationData: ConversationTurn[]` - 話者付き会話データ

**出力**:
- `score: number` - 0-100のスコア
- `value: number` - ポジティブ比率（%）
- `details: EmotionAnalysisDetails` - 詳細データ

**アルゴリズム**:

```typescript
// src/domain/services/analysis/emotionAnalyzer.ts

interface EmotionAnalysisResult {
  score: number;
  value: number;
  details: {
    positiveRatio: number;
    keywords: string[];
    overall: 'positive' | 'neutral' | 'negative';
    timeline: Array<{
      time: number;
      sentiment: 'positive' | 'neutral' | 'negative';
      score: number;
    }>;
  };
}

/**
 * ポジティブキーワード辞書
 */
const POSITIVE_KEYWORDS = [
  // 喜び・満足
  '嬉しい', 'うれしい', '楽しい', 'たのしい', '素敵', 'すてき',
  '良い', 'いい', '最高', 'さいこう', '完璧', 'かんぺき',
  'ありがとう', '感謝', 'かんしゃ', '助かる', 'たすかる',
  // 期待・興味
  '楽しみ', 'たのしみ', '気になる', 'きになる', '興味', 'きょうみ',
  'やってみたい', '試したい', 'ためしたい',
  // 肯定
  'そうですね', 'いいですね', '確かに', 'たしかに',
  'なるほど', 'わかります', 'おっしゃる通り',
  // 美容関連ポジティブ
  'サラサラ', 'さらさら', 'ツヤツヤ', 'つやつや', 'まとまる',
  '似合う', 'にあう', 'きれい', 'キレイ', '綺麗',
];

/**
 * ネガティブキーワード辞書
 */
const NEGATIVE_KEYWORDS = [
  // 不満・困り
  '困る', 'こまる', '嫌', 'いや', 'イヤ', '辛い', 'つらい',
  'ダメ', 'だめ', '駄目', '無理', 'むり',
  // 悩み関連
  '悩み', 'なやみ', '心配', 'しんぱい', '不安', 'ふあん',
  'ストレス', 'すとれす',
  // 髪の悩み
  'パサパサ', 'ぱさぱさ', 'ボサボサ', 'ぼさぼさ',
  'うねる', 'ひろがる', '広がる', 'まとまらない',
  // 否定
  'でも', 'ただ', 'ちょっと', '少し', 'すこし',
];

/**
 * 感情分析（ローカル処理 + Claude API）
 */
export async function analyzeEmotion(
  conversationData: ConversationTurn[],
  claudeApiKey?: string
): Promise<EmotionAnalysisResult> {
  const customerUtterances = conversationData.filter(
    turn => turn.speaker === 'customer'
  );

  if (customerUtterances.length === 0) {
    return {
      score: 50,
      value: 50,
      details: {
        positiveRatio: 50,
        keywords: [],
        overall: 'neutral',
        timeline: [],
      },
    };
  }

  // ローカル処理：キーワードベース分析
  const localResult = analyzeEmotionLocal(customerUtterances);

  // Claude APIが利用可能な場合は高度な分析
  if (claudeApiKey) {
    try {
      const aiResult = await analyzeEmotionWithClaude(
        customerUtterances,
        claudeApiKey
      );
      // AI結果とローカル結果をマージ
      return mergeEmotionResults(localResult, aiResult);
    } catch (error) {
      console.error('Claude API emotion analysis failed:', error);
      // フォールバックでローカル結果を使用
    }
  }

  return localResult;
}

/**
 * ローカル感情分析（キーワードベース）
 */
function analyzeEmotionLocal(
  utterances: ConversationTurn[]
): EmotionAnalysisResult {
  const timeline: EmotionAnalysisResult['details']['timeline'] = [];
  const detectedKeywords: string[] = [];
  let positiveCount = 0;
  let negativeCount = 0;

  for (const utterance of utterances) {
    const text = utterance.text;
    let utterancePositive = 0;
    let utteranceNegative = 0;

    // ポジティブキーワード検出
    for (const keyword of POSITIVE_KEYWORDS) {
      if (text.includes(keyword)) {
        utterancePositive++;
        if (!detectedKeywords.includes(keyword)) {
          detectedKeywords.push(keyword);
        }
      }
    }

    // ネガティブキーワード検出
    for (const keyword of NEGATIVE_KEYWORDS) {
      if (text.includes(keyword)) {
        utteranceNegative++;
        if (!detectedKeywords.includes(keyword)) {
          detectedKeywords.push(keyword);
        }
      }
    }

    positiveCount += utterancePositive;
    negativeCount += utteranceNegative;

    // 発話単位の感情判定
    let sentiment: 'positive' | 'neutral' | 'negative' = 'neutral';
    let sentimentScore = 50;

    if (utterancePositive > utteranceNegative) {
      sentiment = 'positive';
      sentimentScore = 70 + Math.min(utterancePositive * 5, 30);
    } else if (utteranceNegative > utterancePositive) {
      sentiment = 'negative';
      sentimentScore = 30 - Math.min(utteranceNegative * 5, 30);
    }

    timeline.push({
      time: utterance.startTime,
      sentiment,
      score: sentimentScore,
    });
  }

  // 全体の感情比率計算
  const totalKeywords = positiveCount + negativeCount;
  const positiveRatio = totalKeywords > 0
    ? (positiveCount / totalKeywords) * 100
    : 50;

  // 全体判定
  let overall: 'positive' | 'neutral' | 'negative' = 'neutral';
  if (positiveRatio >= 60) overall = 'positive';
  else if (positiveRatio <= 40) overall = 'negative';

  // スコア計算
  const score = calculateEmotionScore(positiveRatio);

  return {
    score,
    value: Math.round(positiveRatio * 100) / 100,
    details: {
      positiveRatio: Math.round(positiveRatio * 100) / 100,
      keywords: detectedKeywords,
      overall,
      timeline,
    },
  };
}

/**
 * Claude APIを使用した感情分析
 */
async function analyzeEmotionWithClaude(
  utterances: ConversationTurn[],
  apiKey: string
): Promise<EmotionAnalysisResult> {
  const customerText = utterances.map(u => u.text).join('\n');

  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 1024,
      messages: [{
        role: 'user',
        content: `以下の美容室でのお客様の発話を感情分析してください。

発話内容:
${customerText}

JSON形式で回答してください（説明不要）:
{
  "positiveRatio": 0から100の数値（ポジティブな発話の割合）,
  "keywords": ["検出された感情を示すキーワードの配列"],
  "overall": "positive" または "neutral" または "negative"
}`,
      }],
    }),
  });

  const result = await response.json();
  const content = result.content[0].text;
  
  // JSONパース
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid JSON response from Claude');
  }
  
  const analysis = JSON.parse(jsonMatch[0]);
  const score = calculateEmotionScore(analysis.positiveRatio);

  return {
    score,
    value: analysis.positiveRatio,
    details: {
      positiveRatio: analysis.positiveRatio,
      keywords: analysis.keywords,
      overall: analysis.overall,
      timeline: [],
    },
  };
}

/**
 * 感情分析スコア計算
 */
function calculateEmotionScore(positiveRatio: number): number {
  if (positiveRatio >= 70) return 100;
  if (positiveRatio >= 60) return 85;
  if (positiveRatio >= 50) return 70;
  if (positiveRatio >= 40) return 55;
  return 40;
}

/**
 * ローカル結果とAI結果のマージ
 */
function mergeEmotionResults(
  local: EmotionAnalysisResult,
  ai: EmotionAnalysisResult
): EmotionAnalysisResult {
  // AI結果を優先しつつ、ローカルのtimelineを保持
  return {
    score: ai.score,
    value: ai.value,
    details: {
      ...ai.details,
      timeline: local.details.timeline,
      keywords: [...new Set([...local.details.keywords, ...ai.details.keywords])],
    },
  };
}
```

---

#### 6.1.4 悩みキーワード検出（Concern Keywords Detection）

**目的**: お客様の髪の悩みに関するキーワードを検出

**入力**:
- `conversationData: ConversationTurn[]` - 話者付き会話データ
- `concernKeywords: string[]` - 検出対象キーワードリスト（店舗設定）

**出力**:
- `score: number` - 0-100のスコア
- `value: number` - 検出有無（0 or 1）
- `details: ConcernKeywordsDetails` - 詳細データ

**アルゴリズム**:

```typescript
// src/domain/services/analysis/concernDetector.ts

interface ConcernKeywordsResult {
  score: number;
  value: number;
  details: {
    detected: boolean;
    detectedKeywords: string[];
    detectedAt: number[];
    context: string;
    keywordOccurrences: Array<{
      keyword: string;
      time: number;
      context: string;
    }>;
  };
}

/**
 * デフォルト悩みキーワード
 */
const DEFAULT_CONCERN_KEYWORDS = [
  // 乾燥系
  '乾燥', 'かんそう', 'パサパサ', 'ぱさぱさ', 'パサつき', 'ぱさつき',
  '潤いがない', 'うるおいがない', 'カサカサ', 'かさかさ',
  // 広がり系
  '広がる', 'ひろがる', '広がり', 'ひろがり', 'まとまらない',
  'ボワッと', 'ぼわっと', '爆発', 'ばくはつ',
  // ダメージ系
  'ダメージ', 'だめーじ', '傷んでる', 'いたんでる', '傷み', 'いたみ',
  '枝毛', 'えだげ', '切れ毛', 'きれげ', 'チリチリ', 'ちりちり',
  // うねり系
  'うねり', 'ウネリ', 'くせ毛', 'クセ毛', 'くせげ',
  'ハネる', 'はねる', 'ハネ', 'はね',
  // 薄毛系
  '薄毛', 'うすげ', 'ボリュームがない', 'ぺたんこ', 'ペタンコ',
  '抜け毛', 'ぬけげ', '細い', 'ほそい', 'コシがない',
  // 白髪系
  '白髪', 'しらが', 'グレイヘア', 'ぐれいへあ',
  // 頭皮系
  '頭皮', 'とうひ', 'かゆい', 'カユイ', 'フケ', 'ふけ',
  'べたつき', 'ベタつき', '臭い', 'におい',
  // その他
  '色落ち', 'いろおち', '退色', 'たいしょく',
  'パーマがとれる', 'カールが弱い',
];

/**
 * 悩みキーワード検出
 */
export function detectConcernKeywords(
  conversationData: ConversationTurn[],
  customKeywords?: string[]
): ConcernKeywordsResult {
  const keywords = customKeywords && customKeywords.length > 0
    ? customKeywords
    : DEFAULT_CONCERN_KEYWORDS;

  const customerUtterances = conversationData.filter(
    turn => turn.speaker === 'customer'
  );

  const detectedKeywords: string[] = [];
  const detectedAt: number[] = [];
  const keywordOccurrences: ConcernKeywordsResult['details']['keywordOccurrences'] = [];
  let contextText = '';

  for (const utterance of customerUtterances) {
    const text = utterance.text;

    for (const keyword of keywords) {
      if (text.includes(keyword) && !detectedKeywords.includes(keyword)) {
        detectedKeywords.push(keyword);
        detectedAt.push(utterance.startTime);
        
        // コンテキスト抽出（キーワード前後20文字）
        const keywordIndex = text.indexOf(keyword);
        const start = Math.max(0, keywordIndex - 20);
        const end = Math.min(text.length, keywordIndex + keyword.length + 20);
        const context = text.substring(start, end);

        keywordOccurrences.push({
          keyword,
          time: utterance.startTime,
          context: `...${context}...`,
        });

        // 初回検出時のコンテキスト保存
        if (!contextText && utterance.text.length > 0) {
          contextText = utterance.text;
        }
      }
    }
  }

  const detected = detectedKeywords.length > 0;

  return {
    score: detected ? 100 : 50,
    value: detected ? 1 : 0,
    details: {
      detected,
      detectedKeywords,
      detectedAt,
      context: contextText.substring(0, 200),
      keywordOccurrences,
    },
  };
}

/**
 * 悩みキーワードのカテゴリ分類
 */
export function categorizeConcerns(
  keywords: string[]
): Record<string, string[]> {
  const categories: Record<string, string[]> = {
    '乾燥': [],
    '広がり': [],
    'ダメージ': [],
    'うねり': [],
    '薄毛': [],
    '白髪': [],
    '頭皮': [],
    'その他': [],
  };

  const categoryMapping: Record<string, string> = {
    '乾燥': '乾燥',
    'パサパサ': '乾燥',
    'パサつき': '乾燥',
    '広がる': '広がり',
    '広がり': '広がり',
    'まとまらない': '広がり',
    'ダメージ': 'ダメージ',
    '傷んでる': 'ダメージ',
    '枝毛': 'ダメージ',
    'うねり': 'うねり',
    'くせ毛': 'うねり',
    '薄毛': '薄毛',
    'ボリュームがない': '薄毛',
    '白髪': '白髪',
    '頭皮': '頭皮',
  };

  for (const keyword of keywords) {
    const category = categoryMapping[keyword] || 'その他';
    if (!categories[category].includes(keyword)) {
      categories[category].push(keyword);
    }
  }

  return categories;
}
```

---

#### 6.1.5 提案タイミング分析（Proposal Timing）

**目的**: 悩みキーワード検出後から商品提案までの時間を分析

**入力**:
- `conversationData: ConversationTurn[]` - 話者付き会話データ
- `concernResult: ConcernKeywordsResult` - 悩みキーワード検出結果

**出力**:
- `score: number` - 0-100のスコア
- `value: number` - 提案までの時間（分）
- `details: ProposalTimingDetails` - 詳細データ

**アルゴリズム**:

```typescript
// src/domain/services/analysis/proposalTimingAnalyzer.ts

interface ProposalTimingResult {
  score: number;
  value: number;
  details: {
    concernDetectedAt: number | null;
    proposalAt: number | null;
    timingMinutes: number | null;
    timingEvaluation: 'optimal' | 'good' | 'late' | 'too_early' | 'no_proposal';
  };
}

/**
 * 商品提案パターン
 */
const PROPOSAL_PATTERNS = [
  // 商品名言及
  /シャンプー|トリートメント|オイル|ミスト|ワックス|スプレー/,
  /ヘアケア|ホームケア/,
  // 提案フレーズ
  /おすすめ|オススメ/,
  /いいですよ|良いですよ/,
  /使ってみ/,
  /試してみ/,
  /こちら.*(商品|製品)/,
  // 効果説明
  /これ.*(効果|効き目)/,
  /サラサラに.*なり/,
  /まとまり.*良く/,
];

/**
 * 提案タイミング分析
 * 
 * スコア計算ロジック:
 * - 理想: 悩み検出後2-5分で提案
 * - 2-5分: 100点（最適タイミング）
 * - 1-2分 or 5-7分: 80点（良好）
 * - 7-10分: 60点（やや遅い）
 * - 1分未満: 60点（やや早い）
 * - 10分以上 or 提案なし: 40点
 */
export function analyzeProposalTiming(
  conversationData: ConversationTurn[],
  concernResult: ConcernKeywordsResult
): ProposalTimingResult {
  // 悩みが検出されていない場合
  if (!concernResult.details.detected) {
    return {
      score: 50,
      value: 0,
      details: {
        concernDetectedAt: null,
        proposalAt: null,
        timingMinutes: null,
        timingEvaluation: 'no_proposal',
      },
    };
  }

  const concernDetectedAt = concernResult.details.detectedAt[0];

  // スタイリストの発話から提案を検出
  const stylistUtterances = conversationData
    .filter(turn => turn.speaker === 'stylist')
    .filter(turn => turn.startTime > concernDetectedAt);  // 悩み検出後のみ

  let proposalAt: number | null = null;

  for (const utterance of stylistUtterances) {
    const isProposal = PROPOSAL_PATTERNS.some(pattern =>
      pattern.test(utterance.text)
    );

    if (isProposal) {
      proposalAt = utterance.startTime;
      break;  // 最初の提案を採用
    }
  }

  // 提案がなかった場合
  if (proposalAt === null) {
    return {
      score: 40,
      value: 0,
      details: {
        concernDetectedAt,
        proposalAt: null,
        timingMinutes: null,
        timingEvaluation: 'no_proposal',
      },
    };
  }

  // タイミング計算（分）
  const timingMinutes = (proposalAt - concernDetectedAt) / 60;
  const { score, evaluation } = evaluateProposalTiming(timingMinutes);

  return {
    score,
    value: Math.round(timingMinutes * 100) / 100,
    details: {
      concernDetectedAt,
      proposalAt,
      timingMinutes: Math.round(timingMinutes * 100) / 100,
      timingEvaluation: evaluation,
    },
  };
}

/**
 * 提案タイミング評価
 */
function evaluateProposalTiming(
  minutes: number
): { score: number; evaluation: ProposalTimingResult['details']['timingEvaluation'] } {
  if (minutes >= 2 && minutes <= 5) {
    return { score: 100, evaluation: 'optimal' };
  }
  
  if ((minutes >= 1 && minutes < 2) || (minutes > 5 && minutes <= 7)) {
    return { score: 80, evaluation: 'good' };
  }
  
  if (minutes < 1) {
    return { score: 60, evaluation: 'too_early' };
  }
  
  if (minutes > 7 && minutes <= 10) {
    return { score: 60, evaluation: 'late' };
  }
  
  // 10分以上
  return { score: 40, evaluation: 'late' };
}
```

---

#### 6.1.6 提案品質分析（Proposal Quality）

**目的**: 商品提案時にベネフィット（効果・メリット）を伝えているか分析

**入力**:
- `conversationData: ConversationTurn[]` - 話者付き会話データ

**出力**:
- `score: number` - 0-100のスコア
- `value: number` - ベネフィット比率（%）
- `details: ProposalQualityDetails` - 詳細データ

**アルゴリズム**:

```typescript
// src/domain/services/analysis/proposalQualityAnalyzer.ts

interface ProposalQualityResult {
  score: number;
  value: number;
  details: {
    hasProposal: boolean;
    benefitRatio: number;
    proposalDetails: Array<{
      text: string;
      type: 'benefit' | 'spec' | 'mixed';
      time: number;
    }>;
    benefitExamples: string[];
    specExamples: string[];
  };
}

/**
 * ベネフィット（効果・メリット）パターン
 */
const BENEFIT_PATTERNS = [
  // 効果・結果
  /サラサラ|さらさら/,
  /ツヤツヤ|つやつや|ツヤ|艶/,
  /まとまり|まとまる/,
  /しっとり/,
  /やわらか|柔らか/,
  /ハリ|コシ/,
  // 改善・解決
  /改善|かいぜん/,
  /解消|かいしょう/,
  /抑え|おさえ/,
  /防ぐ|ふせぐ/,
  // お客様目線
  /楽に|らくに/,
  /簡単に|かんたんに/,
  /時短/,
  /朝.*(楽|簡単)/,
  // 感情的ベネフィット
  /自信/,
  /喜/,
  /褒め/,
];

/**
 * スペック（成分・機能）パターン
 */
const SPEC_PATTERNS = [
  // 成分
  /成分/,
  /配合/,
  /オイル|エキス/,
  /ヒアルロン|コラーゲン|ケラチン/,
  /アミノ酸/,
  // 機能・仕様
  /ml|ミリリットル/,
  /プロ仕様/,
  /サロン専売/,
  /持続|もつ/,
  // 価格
  /円|¥/,
  /コスパ/,
];

/**
 * 提案品質分析
 * 
 * スコア計算ロジック:
 * - ベネフィット比率70%以上: 100点
 * - ベネフィット比率50-70%: 80点
 * - ベネフィット比率30-50%: 60点
 * - ベネフィット比率30%未満 or 提案なし: 40点
 */
export async function analyzeProposalQuality(
  conversationData: ConversationTurn[],
  claudeApiKey?: string
): Promise<ProposalQualityResult> {
  const stylistUtterances = conversationData.filter(
    turn => turn.speaker === 'stylist'
  );

  // 提案を含む発話を検出
  const proposalUtterances = stylistUtterances.filter(utterance => {
    return PROPOSAL_PATTERNS.some(pattern => pattern.test(utterance.text)) ||
           BENEFIT_PATTERNS.some(pattern => pattern.test(utterance.text)) ||
           SPEC_PATTERNS.some(pattern => pattern.test(utterance.text));
  });

  if (proposalUtterances.length === 0) {
    return {
      score: 40,
      value: 0,
      details: {
        hasProposal: false,
        benefitRatio: 0,
        proposalDetails: [],
        benefitExamples: [],
        specExamples: [],
      },
    };
  }

  // ローカル分析
  const proposalDetails: ProposalQualityResult['details']['proposalDetails'] = [];
  const benefitExamples: string[] = [];
  const specExamples: string[] = [];
  let benefitCount = 0;
  let specCount = 0;

  for (const utterance of proposalUtterances) {
    const hasBenefit = BENEFIT_PATTERNS.some(p => p.test(utterance.text));
    const hasSpec = SPEC_PATTERNS.some(p => p.test(utterance.text));

    let type: 'benefit' | 'spec' | 'mixed' = 'spec';
    if (hasBenefit && hasSpec) {
      type = 'mixed';
      benefitCount += 0.5;
      specCount += 0.5;
    } else if (hasBenefit) {
      type = 'benefit';
      benefitCount++;
      if (benefitExamples.length < 3) {
        benefitExamples.push(utterance.text.substring(0, 50));
      }
    } else {
      specCount++;
      if (specExamples.length < 3) {
        specExamples.push(utterance.text.substring(0, 50));
      }
    }

    proposalDetails.push({
      text: utterance.text,
      type,
      time: utterance.startTime,
    });
  }

  const total = benefitCount + specCount;
  const benefitRatio = total > 0 ? (benefitCount / total) * 100 : 0;
  const score = calculateProposalQualityScore(benefitRatio);

  return {
    score,
    value: Math.round(benefitRatio * 100) / 100,
    details: {
      hasProposal: true,
      benefitRatio: Math.round(benefitRatio * 100) / 100,
      proposalDetails,
      benefitExamples,
      specExamples,
    },
  };
}

/**
 * 提案品質スコア計算
 */
function calculateProposalQualityScore(benefitRatio: number): number {
  if (benefitRatio >= 70) return 100;
  if (benefitRatio >= 50) return 80;
  if (benefitRatio >= 30) return 60;
  return 40;
}

// 商品提案検出用パターン（再利用）
const PROPOSAL_PATTERNS = [
  /シャンプー|トリートメント|オイル|ミスト/,
  /おすすめ|オススメ/,
  /使ってみ/,
];
```

---

#### 6.1.7 成約判定（Conversion Detection）

**目的**: 商品購入の成約があったかを検出

**入力**:
- `conversationData: ConversationTurn[]` - 話者付き会話データ

**出力**:
- `score: number` - 0-100のスコア
- `value: number` - 成約有無（0 or 1）
- `details: ConversionDetails` - 詳細データ

**アルゴリズム**:

```typescript
// src/domain/services/analysis/conversionDetector.ts

interface ConversionResult {
  score: number;
  value: number;
  details: {
    converted: boolean;
    productName: string | null;
    conversionSignals: string[];
    detectedAt: number | null;
  };
}

/**
 * 成約シグナルパターン
 */
const CONVERSION_SIGNALS = {
  // 購入意思表明（お客様）
  customerBuy: [
    /買い(ます|たい)/,
    /購入(し|したい)/,
    /もらい(ます|たい)/,
    /お願い(し|します)/,
    /それ.*(ください|下さい)/,
    /これ.*(ください|下さい)/,
    /いただ(け|き)/,
  ],
  // 決定表現（お客様）
  customerDecision: [
    /じゃあ.*それ/,
    /それに(します|しよう)/,
    /決め(まし|た)/,
  ],
  // 購入確認（スタイリスト）
  stylistConfirm: [
    /ありがとうございます.*お買い上げ/,
    /では.*こちら/,
    /お会計/,
    /レジ/,
    /包み/,
  ],
};

/**
 * 商品名検出パターン
 */
const PRODUCT_NAME_PATTERNS = [
  // 一般的な商品カテゴリ
  /([\w\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]+)(シャンプー|トリートメント|オイル|ミスト|ワックス|スプレー)/,
  // 商品名＋「を」「が」
  /「([^」]+)」(を|が|は)/,
];

/**
 * 成約判定
 */
export function detectConversion(
  conversationData: ConversationTurn[]
): ConversionResult {
  const conversionSignals: string[] = [];
  let converted = false;
  let productName: string | null = null;
  let detectedAt: number | null = null;

  // お客様の発話から購入意思を検出
  const customerUtterances = conversationData.filter(
    turn => turn.speaker === 'customer'
  );

  for (const utterance of customerUtterances) {
    // 購入意思パターン
    for (const pattern of CONVERSION_SIGNALS.customerBuy) {
      if (pattern.test(utterance.text)) {
        converted = true;
        detectedAt = detectedAt || utterance.startTime;
        conversionSignals.push(`購入意思: "${utterance.text.substring(0, 30)}..."`);
        break;
      }
    }

    // 決定パターン
    for (const pattern of CONVERSION_SIGNALS.customerDecision) {
      if (pattern.test(utterance.text)) {
        converted = true;
        detectedAt = detectedAt || utterance.startTime;
        conversionSignals.push(`購入決定: "${utterance.text.substring(0, 30)}..."`);
        break;
      }
    }
  }

  // スタイリストの発話から購入確認を検出
  const stylistUtterances = conversationData.filter(
    turn => turn.speaker === 'stylist'
  );

  for (const utterance of stylistUtterances) {
    for (const pattern of CONVERSION_SIGNALS.stylistConfirm) {
      if (pattern.test(utterance.text)) {
        converted = true;
        detectedAt = detectedAt || utterance.startTime;
        conversionSignals.push(`購入確認: "${utterance.text.substring(0, 30)}..."`);
        break;
      }
    }
  }

  // 商品名の抽出
  if (converted) {
    const allText = conversationData.map(t => t.text).join(' ');
    for (const pattern of PRODUCT_NAME_PATTERNS) {
      const match = allText.match(pattern);
      if (match) {
        productName = match[1] || match[0];
        break;
      }
    }
  }

  return {
    score: converted ? 100 : 50,
    value: converted ? 1 : 0,
    details: {
      converted,
      productName,
      conversionSignals,
      detectedAt,
    },
  };
}

/**
 * Claude APIを使用した高度な成約判定
 */
export async function detectConversionWithClaude(
  conversationData: ConversationTurn[],
  apiKey: string
): Promise<ConversionResult> {
  const conversationText = conversationData
    .map(t => `[${t.speaker === 'stylist' ? 'スタイリスト' : 'お客様'}] ${t.text}`)
    .join('\n');

  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 512,
      messages: [{
        role: 'user',
        content: `以下の美容室での会話から、商品の購入（成約）があったかを判定してください。

会話:
${conversationText}

JSON形式で回答（説明不要）:
{
  "converted": true または false,
  "productName": "購入された商品名" または null,
  "confidence": 0から100の確信度
}`,
      }],
    }),
  });

  const result = await response.json();
  const content = result.content[0].text;
  
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    throw new Error('Invalid JSON response');
  }
  
  const analysis = JSON.parse(jsonMatch[0]);

  return {
    score: analysis.converted ? 100 : 50,
    value: analysis.converted ? 1 : 0,
    details: {
      converted: analysis.converted,
      productName: analysis.productName,
      conversionSignals: [],
      detectedAt: null,
    },
  };
}
```

---

### 6.2 総合スコア計算アルゴリズム

```typescript
// src/domain/services/analysis/overallScoreCalculator.ts

interface IndicatorWeight {
  type: IndicatorType;
  weight: number;
}

/**
 * 指標の重み付け設定
 */
const INDICATOR_WEIGHTS: IndicatorWeight[] = [
  { type: 'talk_ratio', weight: 0.15 },
  { type: 'question_analysis', weight: 0.15 },
  { type: 'emotion_analysis', weight: 0.15 },
  { type: 'concern_keywords', weight: 0.10 },
  { type: 'proposal_timing', weight: 0.15 },
  { type: 'proposal_quality', weight: 0.15 },
  { type: 'conversion', weight: 0.15 },
];

/**
 * 総合スコア計算
 * 
 * 計算式: Σ(指標スコア × 重み) / Σ(有効な重み)
 */
export function calculateOverallScore(
  analysisResults: Map<IndicatorType, { score: number; value: number }>
): number {
  let totalScore = 0;
  let totalWeight = 0;

  for (const { type, weight } of INDICATOR_WEIGHTS) {
    const result = analysisResults.get(type);
    if (result) {
      totalScore += result.score * weight;
      totalWeight += weight;
    }
  }

  if (totalWeight === 0) {
    return 0;
  }

  // 重みの合計で正規化
  const normalizedScore = (totalScore / totalWeight) * (1 / totalWeight) * totalWeight;
  
  return Math.round(normalizedScore * 100) / 100;
}

/**
 * スコアランク判定
 */
export function getScoreRank(score: number): ScoreRank {
  if (score >= 90) return { rank: 'S', label: '素晴らしい', color: '#FFD700' };
  if (score >= 80) return { rank: 'A', label: '良い', color: '#10B981' };
  if (score >= 70) return { rank: 'B', label: '普通', color: '#6366F1' };
  if (score >= 60) return { rank: 'C', label: '要改善', color: '#F59E0B' };
  return { rank: 'D', label: '要注意', color: '#EF4444' };
}

interface ScoreRank {
  rank: 'S' | 'A' | 'B' | 'C' | 'D';
  label: string;
  color: string;
}

type IndicatorType =
  | 'talk_ratio'
  | 'question_analysis'
  | 'emotion_analysis'
  | 'concern_keywords'
  | 'proposal_timing'
  | 'proposal_quality'
  | 'conversion';
```

---

### 6.3 ベクトル検索アルゴリズム

```typescript
// src/domain/services/search/vectorSearchService.ts

/**
 * 成功事例検索のためのベクトル検索サービス
 */
export class VectorSearchService {
  private readonly supabase: SupabaseClient;
  private readonly openaiApiKey: string;
  
  constructor(supabase: SupabaseClient, openaiApiKey: string) {
    this.supabase = supabase;
    this.openaiApiKey = openaiApiKey;
  }

  /**
   * 成功事例を検索
   */
  async searchSuccessCases(params: {
    concernKeywords: string[];
    customerInfo?: CustomerInfo;
    salonId: string;
    limit?: number;
    threshold?: number;
  }): Promise<SearchResult[]> {
    const { concernKeywords, customerInfo, salonId, limit = 5, threshold = 0.7 } = params;

    // 1. 検索クエリテキストを生成
    const queryText = this.buildQueryText(concernKeywords, customerInfo);

    // 2. Embeddingを生成
    const embedding = await this.createEmbedding(queryText);

    // 3. ベクトル検索（pgvector）
    const { data, error } = await this.supabase.rpc('search_success_cases', {
      query_embedding: embedding,
      match_threshold: threshold,
      match_count: limit,
      salon_id: salonId,
    });

    if (error) {
      console.error('Vector search error:', error);
      // フォールバック: キーワード検索
      return this.fallbackKeywordSearch(concernKeywords, salonId, limit);
    }

    return data.map((item: any) => ({
      id: item.id,
      concernKeywords: item.concern_keywords,
      successfulTalk: item.successful_talk,
      keyTactics: item.key_tactics,
      soldProduct: item.sold_product,
      similarity: item.similarity,
    }));
  }

  /**
   * 検索クエリテキストを生成
   */
  private buildQueryText(
    concernKeywords: string[],
    customerInfo?: CustomerInfo
  ): string {
    const parts: string[] = [];

    // 悩みキーワード
    if (concernKeywords.length > 0) {
      parts.push(`悩み: ${concernKeywords.join(', ')}`);
    }

    // お客様属性
    if (customerInfo) {
      if (customerInfo.ageGroup) {
        parts.push(`年代: ${customerInfo.ageGroup}`);
      }
      if (customerInfo.gender) {
        parts.push(`性別: ${customerInfo.gender}`);
      }
    }

    return parts.join('\n');
  }

  /**
   * OpenAI Embedding生成
   */
  private async createEmbedding(text: string): Promise<number[]> {
    const response = await fetch('https://api.openai.com/v1/embeddings', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.openaiApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'text-embedding-3-small',
        input: text,
      }),
    });

    if (!response.ok) {
      throw new Error(`Embedding API error: ${response.status}`);
    }

    const result = await response.json();
    return result.data[0].embedding;
  }

  /**
   * フォールバック: キーワードベース検索
   */
  private async fallbackKeywordSearch(
    keywords: string[],
    salonId: string,
    limit: number
  ): Promise<SearchResult[]> {
    const { data, error } = await this.supabase
      .from('success_cases')
      .select('*')
      .or(`salon_id.eq.${salonId},is_public.eq.true`)
      .overlaps('concern_keywords', keywords)
      .limit(limit);

    if (error) {
      console.error('Keyword search error:', error);
      return [];
    }

    return data.map((item: any) => ({
      id: item.id,
      concernKeywords: item.concern_keywords,
      successfulTalk: item.successful_talk,
      keyTactics: item.key_tactics,
      soldProduct: item.sold_product,
      similarity: null,  // キーワード検索では類似度なし
    }));
  }
}

interface SearchResult {
  id: string;
  concernKeywords: string[];
  successfulTalk: string;
  keyTactics: string[];
  soldProduct: string | null;
  similarity: number | null;
}

interface CustomerInfo {
  ageGroup?: string;
  gender?: string;
}
```

---

（続きは Part 5 に記載: データベース物理設計、画面項目詳細定義）
# 詳細設計書 Part 5: データベース物理設計・画面項目詳細定義

---
